# Создание и использование класса

# Классы позволяют моделировать практически все что угодно. Начнем с написания
# простого класса Dog, представляющего собаку — не какую-то конкретную, а собаку
# вообще. Что мы знаем о собаках? У них есть кличка и возраст. Также известно, что
# большинство собак умеют садиться и перекатываться по команде. Эти два вида
# информации (кличка и возраст) и два вида поведения (сидеть и перекатываться)
# будут включены в класс Dog, потому что они являются общими для большинства
# собак. Класс сообщает Python, как создать объект, представляющий собаку. По-
# сле того как класс будет написан, мы используем его для создания экземпляров,
# каждый из которых представляет одну конкретную собаку.

# --------------------------------------------------------------------------------------------------------------------

# Создание класса Dog

# В каждом экземпляре, созданном на основе класса Dog, будет храниться кличка
# и возраст; кроме того, в нем будут присутствовать методы sit() и roll_over():

# class Dog():  # 1
#     """Простая модель собаки."""  # 2


# def __init__(self, name, age):  # 3
#     """Инициализирует атрибуты name и age."""

# self.name = name  # 4
# self.age = age


# def site(self):  # 5
#     """Собака садится по команде."""
#     print(self.name.title() + " сейчас сидит.")


# def roll_over(self):
#     """Собака перекатывается по команде."""
#     print(self.name.title() + "сейчас перекатывается!")

# В этом коде есть много мест, заслуживающих вашего внимания, но не беспокойтесь.
# Эта структура неоднократно встретится вам в этой главе, и вы еще успеете к ней
# привыкнуть. В точке  определяется класс с именем Dog. По общепринятым согла-
# шениям имена, начинающиеся с символа верхнего регистра, в Python обозначают
# классы. Круглые скобки в определении класса пусты, потому что класс создается
# с нуля. В точке  приведена строка документации с кратким описанием класса.
#
# Метод __init__()
#
# Функция, являющаяся частью класса, называется методом. Все, что вы узнали
# ранее о функциях, также относится и к методам; единственное практическое раз-
# личие — способ вызова методов. Метод __init__() в точке  — специальный метод,
# который автоматически выполняется при создании каждого нового экземпляра
# на базе класса Dog. Имя метода начинается и заканчивается двумя символами
# подчеркивания; эта схема предотвращает конфликты имен стандартных методов
# Python и методов ваших классов.
# 162 Глава 9 • Классы
# Метод __init__() определяется с тремя параметрами: self, name и age. Пара-
# метр self обязателен в определении метода; он должен предшествовать всем
# остальным параметрам. Он должен быть включен в определение для того, чтобы
# при будущем
# вызове метода __init__() (для создания экземпляра Dog) автомати-
# чески передавался аргумент self. При каждом вызове метода, связанного с клас-
# сом, автоматически передается self — ссылка на экземпляр; она предоставляет
# конкретному экземпляру доступ к атрибутам и методам класса. Когда вы создаете
# экземпляр Dog, Python вызывает метод __init__() из класса Dog. Мы передаем
# Dog() кличку и возраст в аргументах; значение self передается автоматически, так
# что его передавать не нужно. Каждый раз, когда вы захотите создать экземпляр
# на основе класса Dog, необходимо предоставить значения только двух последних
# аргументов name и age.
# Каждая из двух переменных, определяемых в точке , имеет префикс self. Лю-
# бая переменная с префиксом self доступна для каждого метода в классе, и вы
# также сможете обращаться к этим переменным в каждом экземпляре, созданном
# на основе класса. Конструкция self.name = name берет значение, хранящееся
# в параметре name, и сохраняет его в переменной name, которая затем связыва-
# ется с создаваемым экземпляром. Процесс также повторяется с self.age = age.
# Переменные, к которым вы обращаетесь через экземпляры, тоже называются
# атрибутами.
# В классе Dog также определяются два метода: sit() и roll_over() . Так как
# этим методам не нужна дополнительная информация (кличка или возраст), они
# определяются с единственным параметром self. Экземпляры, которые будут
# созданы позднее, смогут вызывать эти методы. Пока методы sit() и roll_over()
# ограничиваются простым выводом сообщения о том, что собака садится или
# перекатывается. Тем не менее концепцию легко расширить для практического
# применения: если бы этот класс был частью компьютерной игры, то эти методы
# вполне могли бы содержать код для создания анимации садящейся или пере-
# катывающейся собаки. А если бы класс был написан для управления роботом,
# то методы могли бы управлять механизмами, заставляющими робота-собаку
# выполнить соответствующую команду.

# ---------------------------------------------------------------------------------------------------------------------

# Создание экземпляра класса

# Считайте, что класс — это своего рода инструкция по созданию экземпляров. Со-
# ответственно, класс Dog — инструкция по созданию экземпляров, представляющих
# конкретных собак.
# Создадим экземпляр, представляющий конкретную собаку:

# my_dog = Dog('вилли', 6)
# print("Имя моей собаки " + my_dog.name.title() + ".")
# print("Моей собаке " + str(my_dog.age) + "лет.")


# Использованный в данном случае класс Dog был написан в предыдущем при-
# мере. В точке  мы приказываем Python создать экземпляр собаки с кличкой
# 'willie' и возрастом 6. В процессе обработки этой строки Python вызывает ме-
# тод __init__() класса Dog с аргументами 'willie' и 6. Метод __init__() создает
# экземпляр,
# представляющий конкретную собаку, и присваивает его атрибутам name
# и age переданные значения. Метод __init__() не содержит явной команды return,
# но Python автоматически возвращает экземпляр, представляющий собаку. Этот
# экземпляр сохраняется в переменной my_dog. Здесь нелишне вспомнить соглаше-
# ния по записи имен: обычно считается, что имя, начинающееся с символа верхнего
# регистра (например, Dog), обозначает класс, а имя, записанное в нижнем регистре
# (например, my_dog), обозначает отдельный экземпляр, созданный на базе класса.
# ---------------------------------------------------------------------------------------------------------------------

# Обращение к атрибутам

# Для обращения к атрибутам экземпляра используется «точечная» запись. В стро-
# ке  мы обращаемся к значению атрибута name экземпляра my_dog:
# my_dog.name
# Точечная запись часто используется в Python. Этот синтаксис показывает, как
# Python ищет значения атрибутов. В данном случае Python обращается к экзем-
# пляру my_dog и ищет атрибут name, связанный с экземпляром my_dog. Это тот же
# атрибут, который обозначался self.name в классе Dog. В точке  тот же прием ис-
# пользуется для работы с атрибутом age. В первой команде print вызов my_dog.name.
# title() записывает 'willie' (значение атрибута name экземпляра my_dog) с символа
# верхнего регистра. Во второй команде print вызов str(my_dog.age) преобразует 6,
# значение атрибута age экземпляра my_dog, в строку.
# Пример выводит сводку известных фактов о my_dog:

# ---------------------------------------------------------------------------------------------------------------------

# Вызов методов

# После создания экземпляра на основе класса Dog можно применять точечную за-
# пись для вызова любых методов, определенных в Dog:

# class Dog():
#     ...


# my_dog = Dog('вилли', 6)
# my_dog.sit()
# my_dog.roll_over()


# Чтобы вызвать метод, укажите экземпляр (в данном случае my_dog) и вызываемый
# метод, разделив их точкой. В ходе обработки my_dog.sit() Python ищет метод sit()
# в классе Dog и выполняет его код. Строка my_dog.roll_over() интерпретируется
# аналогичным образом.
# Теперь экземпляр послушно выполняет полученные команды:
# Willie is now sitting.
# Willie rolled over!
# Это очень полезный синтаксис. Если атрибутам и методам были присвоены содер-
# жательные имена (например, name, age, sit() и roll_over()), разработчик сможет
# легко понять, что делает блок кода, — даже если он видит этот блок впервые.

# ------------------------------------------------------------------------------------------------------------------

# Создание нескольких экземпляров

# На основе класса можно создать столько экземпляров, сколько вам потребуется.
# Создадим второй экземпляр Dog с именем your_dog:

# class Dog():
#     ...


# my_dog = Dog('willie', 6)
# your_dog = Dog('lucy', 3)
# print("My dog's name is " + my_dog.name.title() + ".")
# print("My dog is " + str(my_dog.age) + " years old.")
# my_dog.sit()
# print("\nYour dog's name is " + your_dog.name.title() + ".")
# print("Your dog is " + str(your_dog.age) + " years old.")
# your_dog.sit()


# В этом примере создаются два экземпляра с именами Willie и Lucy. Каждый экзем-
# пляр обладает своим набором атрибутов и способен выполнять действия из общего
# набора:

# Даже если второй собаке будут назначены те же имя и возраст, Python все
# равно создаст отдельный экземпляр класса Dog. Вы можете создать сколько
# угодно экземпляров
# одного класса при условии, что эти экземпляры хранятся
# в переменных с разными именами или занимают разные позиции в списке или
# словаре:

# ---------------------------------------------------------------------------------------------------------------------
# УПРАЖНЕНИЯ

# 9-1. Ресторан: создайте класс с именем Restaurant. Метод __init__() класса Restaurant дол-
# жен содержать два атрибута: restaurant_name и cuisine_type. Создайте метод describe_
# restaurant(), который выводит два атрибута, и метод open_restaurant(), который выводит
# сообщение о том, что ресторан открыт.
# Создайте на основе своего класса экземпляр с именем restaurant. Выведите два атрибута по
# отдельности, затем вызовите оба метода.

# class Restaurant():
#     """Создание ресторана."""

# def __init__(self, restaurant_name, cuisine_type):
#     """Инициализация атрибута restaurant_name, cuisine_type """
#     self.restaurant_name = restaurant_name
#     self.cuisine_type = cuisine_type

# def describe_restaurant(self):
#     """Описание ресторана."""
#     print(self.cuisine_type.title() + " типичная кухня.")

# def open_restaurant(self):
#     """Открытие ресторана"""
#     print(self.restaurant_name.title() + " ресторан открылся!")


# restaurant = Restaurant("дикая роза", "русская народная кухня")
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")
# print(restaurant.restaurant_name.title() + " : " + restaurant.cuisine_type.title() + ".")

# --------------------------------------------------------------------------------------------------------------------

# 9-2. Три ресторана: начните с класса из упражнения 9-1. Создайте три разных экземпляра,
# вызовите для каждого экземпляра метод describe_restaurant().

# class Restaurant():
#     """Создание ресторана."""

# def __init__(self, restaurant_name, cuisine_type, stile, attendance):
#     """Инициализация атрибута restaurant_name, cuisine_type """
#     self.restaurant_name = restaurant_name
#     self.cuisine_type = cuisine_type
#     self.stile = stile
#     self.attendance = attendance

# def describe_restaurant(self):
#     """Описание ресторана."""
#     print(self.cuisine_type.title() + " " + self.stile + ", кол - во людей за день: " + str(self.attendance))

# def open_restaurant(self):
#     """Открытие ресторана"""
#     print("Добро пожаловать! Ресторан " + self.restaurant_name.title() + " открылся!")


# restaurant = Restaurant("дикая роза", "типичная кухня", "итальянской стилистики", 3000)
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")

# restaurant.describe_restaurant()
# restaurant.open_restaurant()

# ---------------------------------------------------------------------------------------------------------------------

# 9-3. Пользователи: создайте класс с именем User. Создайте два атрибута first_name и last_
# name, а затем еще несколько атрибутов, которые обычно хранятся в профиле пользова-
# теля. Напишите метод describe_user(), который выводит сводку с информацией о пользо-
# вателе. Создайте еще один метод greet_user() для вывода персонального приветствия для
# пользователя.
# Создайте несколько экземпляров, представляющих разных пользователей. Вызовите оба
# метода для каждого пользователя.

class User():
    """sozdanie polzovatelia"""

    def __init__(self, first_name, last_name, age, sex):
        """Инициализируем пользователя."""
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.sex = sex

    def describe_user(self):
        """Описание пользователя"""
        summary_of_informations = ("Имя: " + self.first_name + "," + " Фамилия: " + self.last_name + "," + " Возраст: " +
                                   str(self.age) + "," + " Пол: " + self.sex).title()
        print(summary_of_informations)

    def greet_user(self):
        """Приветствие пользователя"""
        print("Приветствую вас! " + self.first_name.title() + " " + self.last_name.title())


print("\t****Описание пользователя:****")
user_1 = User("vladimer", "rahmano", 32, "man")
user_2 = User("dmitry", "halikov", 34, "man")
user_3 = User("oleg", "evseev", 37, "man")

user_1.describe_user()
user_2.describe_user()
user_3.describe_user()
print("----------------------------------------------------------")
print("\t****Приветствие пользователя:****")
user_1.greet_user()
user_2.greet_user()
user_3.greet_user()
