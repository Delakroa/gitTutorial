# Создание и использование класса

# Классы позволяют моделировать практически все что угодно. Начнем с написания
# простого класса Dog, представляющего собаку — не какую-то конкретную, а собаку
# вообще. Что мы знаем о собаках? У них есть кличка и возраст. Также известно, что
# большинство собак умеют садиться и перекатываться по команде. Эти два вида
# информации (кличка и возраст) и два вида поведения (сидеть и перекатываться)
# будут включены в класс Dog, потому что они являются общими для большинства
# собак. Класс сообщает Python, как создать объект, представляющий собаку. По-
# сле того как класс будет написан, мы используем его для создания экземпляров,
# каждый из которых представляет одну конкретную собаку.

# --------------------------------------------------------------------------------------------------------------------

# Создание класса Dog

# В каждом экземпляре, созданном на основе класса Dog, будет храниться кличка
# и возраст; кроме того, в нем будут присутствовать методы sit() и roll_over():

class Dog():    #1
    """Простая модель собаки."""    #2

    def __init__(self, name, age):    #3
        """Инициализирует атрибуты name и age."""
        self.name = name   #4
        self.age = age

    def site(self):     #5
        """Собака садится по команде."""
        print(self.name.title() + " сейчас сидит.")
    def roll_over(self):
        """Собака перекатывается по команде."""
        print(self.name.title() + "сейчас перекатывается!")


# В этом коде есть много мест, заслуживающих вашего внимания, но не беспокойтесь.
# Эта структура неоднократно встретится вам в этой главе, и вы еще успеете к ней
# привыкнуть. В точке  определяется класс с именем Dog. По общепринятым согла-
# шениям имена, начинающиеся с символа верхнего регистра, в Python обозначают
# классы. Круглые скобки в определении класса пусты, потому что класс создается
# с нуля. В точке  приведена строка документации с кратким описанием класса.
#
# Метод __init__()
#
# Функция, являющаяся частью класса, называется методом. Все, что вы узнали
# ранее о функциях, также относится и к методам; единственное практическое раз-
# личие — способ вызова методов. Метод __init__() в точке  — специальный метод,
# который автоматически выполняется при создании каждого нового экземпляра
# на базе класса Dog. Имя метода начинается и заканчивается двумя символами
# подчеркивания; эта схема предотвращает конфликты имен стандартных методов
# Python и методов ваших классов.
# 162 Глава 9 • Классы
# Метод __init__() определяется с тремя параметрами: self, name и age. Пара-
# метр self обязателен в определении метода; он должен предшествовать всем
# остальным параметрам. Он должен быть включен в определение для того, чтобы
# при будущем
# вызове метода __init__() (для создания экземпляра Dog) автомати-
# чески передавался аргумент self. При каждом вызове метода, связанного с клас-
# сом, автоматически передается self — ссылка на экземпляр; она предоставляет
# конкретному экземпляру доступ к атрибутам и методам класса. Когда вы создаете
# экземпляр Dog, Python вызывает метод __init__() из класса Dog. Мы передаем
# Dog() кличку и возраст в аргументах; значение self передается автоматически, так
# что его передавать не нужно. Каждый раз, когда вы захотите создать экземпляр
# на основе класса Dog, необходимо предоставить значения только двух последних
# аргументов name и age.
# Каждая из двух переменных, определяемых в точке , имеет префикс self. Лю-
# бая переменная с префиксом self доступна для каждого метода в классе, и вы
# также сможете обращаться к этим переменным в каждом экземпляре, созданном
# на основе класса. Конструкция self.name = name берет значение, хранящееся
# в параметре name, и сохраняет его в переменной name, которая затем связыва-
# ется с создаваемым экземпляром. Процесс также повторяется с self.age = age.
# Переменные, к которым вы обращаетесь через экземпляры, тоже называются
# атрибутами.
# В классе Dog также определяются два метода: sit() и roll_over() . Так как
# этим методам не нужна дополнительная информация (кличка или возраст), они
# определяются с единственным параметром self. Экземпляры, которые будут
# созданы позднее, смогут вызывать эти методы. Пока методы sit() и roll_over()
# ограничиваются простым выводом сообщения о том, что собака садится или
# перекатывается. Тем не менее концепцию легко расширить для практического
# применения: если бы этот класс был частью компьютерной игры, то эти методы
# вполне могли бы содержать код для создания анимации садящейся или пере-
# катывающейся собаки. А если бы класс был написан для управления роботом,
# то методы могли бы управлять механизмами, заставляющими робота-собаку
# выполнить соответствующую команду.