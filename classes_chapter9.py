# Создание и использование класса

# Классы позволяют моделировать практически все что угодно. Начнем с написания
# простого класса Dog, представляющего собаку — не какую-то конкретную, а собаку
# вообще. Что мы знаем о собаках? У них есть кличка и возраст. Также известно, что
# большинство собак умеют садиться и перекатываться по команде. Эти два вида
# информации (кличка и возраст) и два вида поведения (сидеть и перекатываться)
# будут включены в класс Dog, потому что они являются общими для большинства
# собак. Класс сообщает Python, как создать объект, представляющий собаку. По-
# сле того как класс будет написан, мы используем его для создания экземпляров,
# каждый из которых представляет одну конкретную собаку.

# --------------------------------------------------------------------------------------------------------------------

# Создание класса Dog

# В каждом экземпляре, созданном на основе класса Dog, будет храниться кличка
# и возраст; кроме того, в нем будут присутствовать методы sit() и roll_over():

# class Dog():  # 1
#     """Простая модель собаки."""  # 2


# def __init__(self, name, age):  # 3
#     """Инициализирует атрибуты name и age."""

# self.name = name  # 4
# self.age = age


# def site(self):  # 5
#     """Собака садится по команде."""
#     print(self.name.title() + " сейчас сидит.")


# def roll_over(self):
#     """Собака перекатывается по команде."""
#     print(self.name.title() + "сейчас перекатывается!")

# В этом коде есть много мест, заслуживающих вашего внимания, но не беспокойтесь.
# Эта структура неоднократно встретится вам в этой главе, и вы еще успеете к ней
# привыкнуть. В точке  определяется класс с именем Dog. По общепринятым согла-
# шениям имена, начинающиеся с символа верхнего регистра, в Python обозначают
# классы. Круглые скобки в определении класса пусты, потому что класс создается
# с нуля. В точке  приведена строка документации с кратким описанием класса.
#
# Метод __init__()
#
# Функция, являющаяся частью класса, называется методом. Все, что вы узнали
# ранее о функциях, также относится и к методам; единственное практическое раз-
# личие — способ вызова методов. Метод __init__() в точке  — специальный метод,
# который автоматически выполняется при создании каждого нового экземпляра
# на базе класса Dog. Имя метода начинается и заканчивается двумя символами
# подчеркивания; эта схема предотвращает конфликты имен стандартных методов
# Python и методов ваших классов.
# 162 Глава 9 • Классы
# Метод __init__() определяется с тремя параметрами: self, name и age. Пара-
# метр self обязателен в определении метода; он должен предшествовать всем
# остальным параметрам. Он должен быть включен в определение для того, чтобы
# при будущем
# вызове метода __init__() (для создания экземпляра Dog) автомати-
# чески передавался аргумент self. При каждом вызове метода, связанного с клас-
# сом, автоматически передается self — ссылка на экземпляр; она предоставляет
# конкретному экземпляру доступ к атрибутам и методам класса. Когда вы создаете
# экземпляр Dog, Python вызывает метод __init__() из класса Dog. Мы передаем
# Dog() кличку и возраст в аргументах; значение self передается автоматически, так
# что его передавать не нужно. Каждый раз, когда вы захотите создать экземпляр
# на основе класса Dog, необходимо предоставить значения только двух последних
# аргументов name и age.
# Каждая из двух переменных, определяемых в точке , имеет префикс self. Лю-
# бая переменная с префиксом self доступна для каждого метода в классе, и вы
# также сможете обращаться к этим переменным в каждом экземпляре, созданном
# на основе класса. Конструкция self.name = name берет значение, хранящееся
# в параметре name, и сохраняет его в переменной name, которая затем связыва-
# ется с создаваемым экземпляром. Процесс также повторяется с self.age = age.
# Переменные, к которым вы обращаетесь через экземпляры, тоже называются
# атрибутами.
# В классе Dog также определяются два метода: sit() и roll_over() . Так как
# этим методам не нужна дополнительная информация (кличка или возраст), они
# определяются с единственным параметром self. Экземпляры, которые будут
# созданы позднее, смогут вызывать эти методы. Пока методы sit() и roll_over()
# ограничиваются простым выводом сообщения о том, что собака садится или
# перекатывается. Тем не менее концепцию легко расширить для практического
# применения: если бы этот класс был частью компьютерной игры, то эти методы
# вполне могли бы содержать код для создания анимации садящейся или пере-
# катывающейся собаки. А если бы класс был написан для управления роботом,
# то методы могли бы управлять механизмами, заставляющими робота-собаку
# выполнить соответствующую команду.

# ---------------------------------------------------------------------------------------------------------------------

# Создание экземпляра класса

# Считайте, что класс — это своего рода инструкция по созданию экземпляров. Со-
# ответственно, класс Dog — инструкция по созданию экземпляров, представляющих
# конкретных собак.
# Создадим экземпляр, представляющий конкретную собаку:

# my_dog = Dog('вилли', 6)
# print("Имя моей собаки " + my_dog.name.title() + ".")
# print("Моей собаке " + str(my_dog.age) + "лет.")


# Использованный в данном случае класс Dog был написан в предыдущем при-
# мере. В точке  мы приказываем Python создать экземпляр собаки с кличкой
# 'willie' и возрастом 6. В процессе обработки этой строки Python вызывает ме-
# тод __init__() класса Dog с аргументами 'willie' и 6. Метод __init__() создает
# экземпляр,
# представляющий конкретную собаку, и присваивает его атрибутам name
# и age переданные значения. Метод __init__() не содержит явной команды return,
# но Python автоматически возвращает экземпляр, представляющий собаку. Этот
# экземпляр сохраняется в переменной my_dog. Здесь нелишне вспомнить соглаше-
# ния по записи имен: обычно считается, что имя, начинающееся с символа верхнего
# регистра (например, Dog), обозначает класс, а имя, записанное в нижнем регистре
# (например, my_dog), обозначает отдельный экземпляр, созданный на базе класса.
# ---------------------------------------------------------------------------------------------------------------------

# Обращение к атрибутам

# Для обращения к атрибутам экземпляра используется «точечная» запись. В стро-
# ке  мы обращаемся к значению атрибута name экземпляра my_dog:
# my_dog.name
# Точечная запись часто используется в Python. Этот синтаксис показывает, как
# Python ищет значения атрибутов. В данном случае Python обращается к экзем-
# пляру my_dog и ищет атрибут name, связанный с экземпляром my_dog. Это тот же
# атрибут, который обозначался self.name в классе Dog. В точке  тот же прием ис-
# пользуется для работы с атрибутом age. В первой команде print вызов my_dog.name.
# title() записывает 'willie' (значение атрибута name экземпляра my_dog) с символа
# верхнего регистра. Во второй команде print вызов str(my_dog.age) преобразует 6,
# значение атрибута age экземпляра my_dog, в строку.
# Пример выводит сводку известных фактов о my_dog:

# ---------------------------------------------------------------------------------------------------------------------

# Вызов методов

# После создания экземпляра на основе класса Dog можно применять точечную за-
# пись для вызова любых методов, определенных в Dog:

# class Dog():
#     ...


# my_dog = Dog('вилли', 6)
# my_dog.sit()
# my_dog.roll_over()


# Чтобы вызвать метод, укажите экземпляр (в данном случае my_dog) и вызываемый
# метод, разделив их точкой. В ходе обработки my_dog.sit() Python ищет метод sit()
# в классе Dog и выполняет его код. Строка my_dog.roll_over() интерпретируется
# аналогичным образом.
# Теперь экземпляр послушно выполняет полученные команды:
# Willie is now sitting.
# Willie rolled over!
# Это очень полезный синтаксис. Если атрибутам и методам были присвоены содер-
# жательные имена (например, name, age, sit() и roll_over()), разработчик сможет
# легко понять, что делает блок кода, — даже если он видит этот блок впервые.

# ------------------------------------------------------------------------------------------------------------------

# Создание нескольких экземпляров

# На основе класса можно создать столько экземпляров, сколько вам потребуется.
# Создадим второй экземпляр Dog с именем your_dog:

# class Dog():
#     ...


# my_dog = Dog('willie', 6)
# your_dog = Dog('lucy', 3)
# print("My dog's name is " + my_dog.name.title() + ".")
# print("My dog is " + str(my_dog.age) + " years old.")
# my_dog.sit()
# print("\nYour dog's name is " + your_dog.name.title() + ".")
# print("Your dog is " + str(your_dog.age) + " years old.")
# your_dog.sit()


# В этом примере создаются два экземпляра с именами Willie и Lucy. Каждый экзем-
# пляр обладает своим набором атрибутов и способен выполнять действия из общего
# набора:

# Даже если второй собаке будут назначены те же имя и возраст, Python все
# равно создаст отдельный экземпляр класса Dog. Вы можете создать сколько
# угодно экземпляров
# одного класса при условии, что эти экземпляры хранятся
# в переменных с разными именами или занимают разные позиции в списке или
# словаре:

# ---------------------------------------------------------------------------------------------------------------------
# УПРАЖНЕНИЯ

# 9-1. Ресторан: создайте класс с именем Restaurant. Метод __init__() класса Restaurant дол-
# жен содержать два атрибута: restaurant_name и cuisine_type. Создайте метод describe_
# restaurant(), который выводит два атрибута, и метод open_restaurant(), который выводит
# сообщение о том, что ресторан открыт.
# Создайте на основе своего класса экземпляр с именем restaurant. Выведите два атрибута по
# отдельности, затем вызовите оба метода.

# class Restaurant():
#     """Создание ресторана."""

# def __init__(self, restaurant_name, cuisine_type):
#     """Инициализация атрибута restaurant_name, cuisine_type """
#     self.restaurant_name = restaurant_name
#     self.cuisine_type = cuisine_type

# def describe_restaurant(self):
#     """Описание ресторана."""
#     print(self.cuisine_type.title() + " типичная кухня.")

# def open_restaurant(self):
#     """Открытие ресторана"""
#     print(self.restaurant_name.title() + " ресторан открылся!")


# restaurant = Restaurant("дикая роза", "русская народная кухня")
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")
# print(restaurant.restaurant_name.title() + " : " + restaurant.cuisine_type.title() + ".")

# --------------------------------------------------------------------------------------------------------------------

# 9-2. Три ресторана: начните с класса из упражнения 9-1. Создайте три разных экземпляра,
# вызовите для каждого экземпляра метод describe_restaurant().

# class Restaurant():
#     """Создание ресторана."""

# def __init__(self, restaurant_name, cuisine_type, stile, attendance):
#     """Инициализация атрибута restaurant_name, cuisine_type """
#     self.restaurant_name = restaurant_name
#     self.cuisine_type = cuisine_type
#     self.stile = stile
#     self.attendance = attendance

# def describe_restaurant(self):
#     """Описание ресторана."""
#     print(self.cuisine_type.title() + " " + self.stile + ", кол - во людей за день: " + str(self.attendance))

# def open_restaurant(self):
#     """Открытие ресторана"""
#     print("Добро пожаловать! Ресторан " + self.restaurant_name.title() + " открылся!")


# restaurant = Restaurant("дикая роза", "типичная кухня", "итальянской стилистики", 3000)
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")

# restaurant.describe_restaurant()
# restaurant.open_restaurant()

# ---------------------------------------------------------------------------------------------------------------------

# 9-3. Пользователи: создайте класс с именем User. Создайте два атрибута first_name и last_
# name, а затем еще несколько атрибутов, которые обычно хранятся в профиле пользова-
# теля. Напишите метод describe_user(), который выводит сводку с информацией о пользо-
# вателе. Создайте еще один метод greet_user() для вывода персонального приветствия для
# пользователя.
# Создайте несколько экземпляров, представляющих разных пользователей. Вызовите оба
# метода для каждого пользователя.

# class User():
#     """sozdanie polzovatelia"""

# def __init__(self, first_name, last_name, age, sex):
#     """Инициализируем пользователя."""
#     self.first_name = first_name
#     self.last_name = last_name
#     self.age = age
#     self.sex = sex

# def describe_user(self):
#     """Описание пользователя"""
#     summary_of_informations = ("Имя: " + self.first_name + "," + " Фамилия: " + self.last_name + "," + " Возраст: " +
#                                str(self.age) + "," + " Пол: " + self.sex).title()
#     print(summary_of_informations)

# def greet_user(self):
#     """Приветствие пользователя"""
#     print("Приветствую вас! " + self.first_name.title() + " " + self.last_name.title())


# print("\t****Описание пользователя:****")
# user_1 = User("vladimir", "rahmano", 32, "man")
# user_2 = User("dmitry", "halikov", 34, "man")
# user_3 = User("oleg", "evseev", 37, "man")

# user_1.describe_user()
# user_2.describe_user()
# user_3.describe_user()
# print("----------------------------------------------------------")
# print("\t****Приветствие пользователя:****")
# user_1.greet_user()
# user_2.greet_user()
# user_3.greet_user()

# ---------------------------------------------------------------------------------------------------------------------

# Работа с классами и экземплярами

# Классы могут использоваться для моделирования многих реальных ситуаций. По-
# сле того как класс будет написан, разработчик проводит бульшую часть времени
# за работой с экземплярами, созданными на основе этого класса. Одной из первых
# задач станет изменение атрибутов, связанных с конкретным экземпляром. Атрибу-
# ты экземпляра можно изменять напрямую или же написать методы, изменяющие
# атрибуты по особым правилам.

# --------------------------------------------------------------------------------------------------------------------

# Класс Car

# Напишем класс, представляющий автомобиль. Этот класс будет содержать инфор-
# мацию о типе машины, а также метод для вывода краткого описания:

# class Car():
#     """Простая модель автомобиля"""

# def __init__(self, make, model, year):  # 1
#     """Инициализация атрибута и описание автомобиля."""
#     self.make = make
#     self.model = model
#     self.year = year

# def get_descriptive_name(self):  # 2
#     """Возвращает аккуратно отформатированное описание."""
#     long_name = (self.make + " " + self.model + " " + str(self.year))
#     return long_name.title()


# my_new_car = Car('audi', 'a4', 2016)  # 3
# print(my_new_car.get_descriptive_name())


# В точке  в классе Car определяется метод __init__(); его список параметров на-
# чинается с self, как и в классе Dog. За ним следуют еще три параметра: make, model
# и year. Метод __init__() получает эти параметры и сохраняет их в атрибутах, ко-
# торые будут связаны с экземплярами, созданными на основе класса. При создании
# нового экземпляра Car необходимо указать фирму-производителя, модель и год
# выпуска для данного экземпляра.
# В точке  определяется метод get_descriptive_name(), который объединяет год
# выпуска, фирму-производителя и модель в одну строку с описанием. Это избавит
# вас от необходимости выводить значение каждого атрибута по отдельности. Для
# работы со значениями атрибутов в этом методе используется синтаксис self.make,
# self.model и self.year.
# В точке  создается экземпляр класса Car, который сохраняется в переменной
# my_new_car. Затем вызов метода get_descriptive_name() показывает, с какой ма-
# шиной работает программа:
# 2016 Audi A4
# Чтобы класс был более интересным, добавим атрибут, изменяющийся со време-
# нем, — в нем будет храниться пробег машины в милях.

# --------------------------------------------------------------------------------------------------------------------

# Назначение атрибуту значения по умолчанию

# Каждый атрибут класса должен иметь исходное значение, даже если оно равно
# 0 или пустой строке. В некоторых случаях (например, при задании значений по
# умолчанию) это исходное значение есть смысл задавать в теле метода __init__();
# в таком случае передавать параметр для этого атрибута при создании объекта
# не обязательно.
# Добавим атрибут с именем odometer_reading, исходное значение которого всегда
# равно 0. Также в класс будет включен метод read_odometer() для чтения текущих
# показаний одометра:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 0   #1
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make + " " + self.model + " " + str(self.year))
#         return long_name.title()
#
#     def read_odometer(self):   #2
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " миль. ")


# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
# my_new_car.read_odometer()


# Когда Python вызывает метод __init__() для создания нового экземпляра, этот
# метод сохраняет фирму-производителя, модель и год выпуска в атрибутах, как
# и в предыдущем случае. Затем Python создает новый атрибут с именем odometer_
# reading и присваивает ему исходное значение 0 . Также в класс добавляется
# новый метод read_odometer() , который упрощает чтение пробега машины
# в милях.

# Сразу же после создания машины ее пробег равен 0:

# 2016 Audi A4
# This car has 0 miles on it.

# Впрочем, у продаваемых машин одометр редко показывает ровно 0, поэтому нам
# понадобится способ изменения значения этого атрибута.

# --------------------------------------------------------------------------------------------------------------------

# Изменение значений атрибутов

# Значение атрибута можно изменить одним из трех способов: изменить его прямо
# в экземпляре, задать значение при помощи метода или изменить его с приращением
# (то есть прибавлением определенной величины) при помощи метода. Рассмотрим
# все эти способы.

# --------------------------------------------------------------------------------------------------------------------

# Прямое изменение значения атрибута

# Чтобы изменить значение атрибута, проще всего обратиться к нему прямо через эк-
# земпляр. В следующем примере на одометре напрямую выставляется значение 23:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 0
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")


# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
# my_new_car.odometer_read = 23   #1
# my_new_car.read_odometer()

# В точке  точечная запись используется для обращения к атрибуту odometer_
# reading экземпляра и прямого присваивания его значения. Эта строка приказывает
# Python взять экземпляр my_new_car, найти связанный с ним атрибут odometer_
# reading и задать значение атрибута равным 23:
# Иногда подобные прямые обращения к атрибутам допустимы, но чаще разработчик
# пишет вспомогательный метод, который изменяет значение за него.

# --------------------------------------------------------------------------------------------------------------------

# Изменение значения атрибута с использованием метода

# В класс можно включить методы, которые изменяют некоторые атрибуты за вас.
# Вместо того чтобы изменять атрибут напрямую, вы передаете новое значение ме-
# тоду, который берет обновление атрибута на себя.
# В следующем примере в класс включается метод update_odometer() для изменения


# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):        # 1
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)    # 2
# my_new_car.read_odometer()


# Класс Car почти не изменился, в нем только добавился метод update_odometer().
# Этот метод получает пробег в милях и сохраняет его в self.odometer_reading.
# В точке  мы вызываем метод update_odometer() и передаем ему значение 23
# в аргументе (соответствующем параметру mileage в определении метода). Метод
# устанавливает на одометре значение 23, а метод read_odometer() выводит текущие
# показания:

# Метод update_odometer() можно расширить так, чтобы при каждом изменении
# показаний одометра выполнялась некоторая дополнительная работа. Добавим
# проверку, которая гарантирует, что никто не будет пытаться сбрасывать показания
# одометра:

# Теперь update_odometer() проверяет новое значение перед изменением атрибута.
# Если новое значение mileage больше или равно текущего, self.odometer_reading,
# показания одометра можно обновить новым значением . Если же новое значение
# меньше текущего, вы получите предупреждение о недопустимости обратной под-
# крутки .

# --------------------------------------------------------------------------------------------------------------------

# Изменение значения атрибута с приращением

# Иногда значение атрибута требуется изменить с заданным приращением (вме-
# сто того чтобы присваивать атрибуту произвольное новое значение). Допустим,
# Работа с классами и экземплярами 169
# вы купили подержанную машину и проехали на ней 100 миль. Следующий метод
# получает величину приращения и прибавляет ее к текущим показаниям одометра:

class Car():
    """Простая модель автомобиля"""

    def __init__(self, make, model, year):
        """Инициализация атрибута и описание автомобиля."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_read = 100

    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""
        long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
        return long_name

    def read_odometer(self):
        """Выводит пробег машины в милях"""
        print("На этой машине пробег " + str(self.odometer_read) + " мили. ")

    def update_odometer(self, mileage):
        """Установить заданное значение на одометре.
        При попытке обратной прокрутки изменени отклоняются."""
        if mileage >= self.odometer_read:
            self.odometer_read = mileage
        else:
            print("Вы не можете скрутить одометр")

    def increment_odometer(self, miles):  # 1
        """Увеличивает показания одометра с заданным приращением."""
        self.odometer_read += miles


my_new_car = Car('audi', 'a4', 2016)
print(my_new_car.get_descriptive_name())

my_new_car.update_odometer(50)  # 2
my_new_car.read_odometer()
print("\t********************")          # нужн понять и исправить работу
my_used_car = Car('subaru', 'outback', 2013)  # 2
print(my_used_car.get_descriptive_name())

my_used_car.update_odometer(23500)  # 3
my_used_car.read_odometer()

my_used_car.increment_odometer(100)  # 4
my_used_car.read_odometer()


# Новый метод increment_odometer() в точке  получает расстояние в милях
# и прибавляет его к self.odometer_reading. В точке  создается экземпляр
# my_used_car. Мы инициализируем показания его одометра значением 23 500;
# для этого вызывается метод update_odometer(), которому передается значение
# 23500 . В точке  вызывается метод increment_odometer(), которому передает-
# ся значение 100, чтобы увеличить показания одометра на 100 миль, пройденные
# с момента покупки: