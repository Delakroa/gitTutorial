# Файлы и исключения

# Чтение из файла

# Гигантские объемы данных доступны в текстовых файлах. В них могут храниться
# погодные данные, социально-экономическая информация, литературные произ-
# ведения и многое другое. Чтение из файла особенно актуально для приложений,
# предназначенных для анализа данных, но оно также может пригодиться в любой
# ситуации, требующей анализа или изменения информации, хранящейся в фай-
# ле. Например, программа может читать содержимое текстового файла и пере-
# писывать его с форматированием, рассчитанным на отображение информации
# в браузере.
# Работа с информацией в текстовом файле начинается с чтения данных в память.
# Вы можете прочитать все содержимое файла или же читать данные по строкам.

# --------------------------------------------------------------------------------------------------------------------

# Чтение всего файла

# Для начала нам понадобится файл с несколькими строками текста. Пусть это будет
# файл с числом «пи» с точностью до 30 знаков, по 10 знаков на строку:

# 3.1415926535
# 8979323846
# 2643383279

# Чтобы опробовать эти примеры, либо введите данные в редакторе и сохраните файл
# с именем pi_digits.txt, либо загрузите файл из ресурсов книги на странице https://
# www.nostarch.com/pythoncrashcourse/. Сохраните файл в каталоге, в котором будут
# храниться программы этой главы.
# Следующая программа открывает этот файл, читает его и выводит содержимое
# на экран:

# with open('D:\Python library\pi_digits.txt') as file_object:
#     contents = file_object.read()
#     print(contents)


# В первой строке этой программы многое заслуживает вашего внимания. Начнем
# с функции open(). Чтобы выполнить любые операции с файлом — даже просто
# вывести его содержимое, — сначала необходимо открыть файл. Функция open()
# получает один аргумент: имя открываемого файла. Python ищет файл с указанным
# именем в каталоге, в котором находится файл текущей программы. В данном при-
# мере выполняется программа file_reader.py, поэтому Python ищет файл pi_digits.txt
# в каталоге, в котором хранится file_reader.py. Функция open() возвращает объект,
# представляющий файл. В данном случае open('pi_digits.txt') возвращает объ-
# ект, представляющий файл pi_digits.txt. Python сохраняет этот объект в переменной
# file_object, с которой мы будем работать позднее в программе.
# Конструкция с ключевым словом with закрывает файл после того, как надобность
# в нем отпадет. Обратите внимание: в этой программе есть вызов open(), но нет
# вызова close(). Файлы можно открывать и закрывать явными вызовами open()
# и close(); но если из-за ошибки в программе команда close() останется невыпол-
# ненной, то файл не будет закрыт. На первый взгляд это не страшно, но некоррект-
# ное закрытие файлов может привести к потере или порче данных. А если функция
# close() будет вызвана слишком рано, программа попытается работать с закрытым
# (то есть недоступным) файлом, что приведет к новым ошибкам. Не всегда можно
# заранее определить, когда нужно закрывать файл, но с приведенной конструкцией
# Python сделает это за вас. Вам остается лишь открыть файл и работать с ним так,
# как требуется, надеясь на то, что Python закроет его автоматически в правильный
# момент.
# После того как в программе появится объект, представляющий файл pi_digits.txt, во
# второй строке программы используется метод read(), который читает все содер-
# жимое файла и сохраняет его содержимое в одной длинной строке в переменной
# contents. При выводе значения contents на экране появляется все содержимое
# файла :

# 3.1415926535
# 8979323846
# 2643383279

# Единственное различие между выводом и исходным файлом — лишняя пустая
# строка в конце вывода. Откуда она взялась? Метод read() возвращает ее при чте-
# нии, если достигнут конец файла. Если вы хотите удалить лишнюю пустую строку,
# включите вызов rstrip() в команду print:

# with open('D:\Python library\pi_digits.txt') as file_object:
#     contents = file_object.read()
#     print(contents.rstrip())

# Напомним, что метод rstrip() удаляет все пропуски в конце строки. Теперь вывод
# точно соответствует содержимому исходного файла:

# --------------------------------------------------------------------------------------------------------------------

# Пути к файлам

# Если передать функции open() простое имя файла, такое как pi_digits.txt, Python
# ищет файл в том каталоге, в котором находится файл, выполняемый в настоящий
# момент (то есть файл программы .py).
# В некоторых случаях (в зависимости от того, как организованы ваши рабочие фай-
# лы) открываемый файл может и не находиться в одном каталоге с файлом програм-
# мы. Например, файл программы может находиться в каталоге python_work; в ката-
# логе python_work создается другой каталог с именем text_files для текстовых файлов,
# с которыми работает программа. И хотя папка text_files находится в python_work,
# простая передача open() имени файла из text_files не подойдет, потому что Python
# проведет поиск файла в python_work и на этом остановится; поиск не будет продол-
# жен во вложенном каталоге text_files. Чтобы открыть файлы из каталога, отличного
# от того, в котором хранится файл программы, необходимо указать путь — то есть
# приказать Python искать файлы в конкретном месте файловой системы.
# Так как каталог text_files находится в python_work, для открытия файла из text_files
# можно воспользоваться относительным путем. Относительный путь приказы-
# вает Python искать файлы в каталоге, который задается относительно каталога,
# в котором находится текущий файл программы. В системе Linux и OS X это вы-
# глядит так:
# with open('text_files/имя_файла.txt') as file_object:
# Эта строка означает, что файл .txt следует искать в каталоге text_files; она предпо-
# лагает, что каталог text_files находится в python_work (так оно и есть). В системах
# Windows в путях к файлам вместо слеша (/) используется обратный слеш (\):
# with open('text_files\имя_файла.txt') as file_object:
# 188 Глава 10 • Файлы и исключения
# Также можно точно определить местонахождение файла в вашей системе неза-
# висимо от того, где хранится выполняемая программа. Такие пути называются
# абсолютными и используются в том случае, если относительный путь не работает.
# Например, если каталог text_files находится не в python_work, а в другом каталоге
# (скажем, в каталоге с именем other_files), то передать open() путь 'text_files/
# filename.txt' не получится, потому что Python будет искать указанный каталог
# только внутри python_work. Чтобы объяснить Python, где следует искать файл, не-
# обходимо записать полный путь.
# Абсолютные пути обычно длиннее относительных, поэтому их лучше сохранять
# в переменных, которые затем передаются open(). В Linux и OS X абсолютные пути
# выглядят так:
# file_path = '/home/ehmatthes/other_files/text_files/имя_файла.txt'
# with open(file_path) as file_object:
# В Windows они выглядят так:
# file_path = 'C:\Users\ehmatthes\other_files\text_files\имя_файла.txt'
# with open(file_path) as file_object:
# С абсолютными путями вы сможете читать файлы из любого каталога вашей си-
# стемы. Пока будет проще хранить файлы в одном каталоге с файлами программ
# или в каталогах, вложенных в каталог с файлами программ (таких как text_files из
# рассмотренного примера).
# ПРИМЕЧАНИЕ
# Иногда в системах семейства Windows слеш в пути к файлам интерпретируется правильно. Если вы
# используете Windows, но не получаете ожидаемых результатов, попробуйте использовать символы
# обратного слеша.

# --------------------------------------------------------------------------------------------------------------------

# Чтение по строкам

# file_name = ('D:\Python library\pi_digits.txt')  # 1
#
# with open(file_name) as file_object:    # 2
#     for line in file_object:   # 3
#         print(line)


# В точке  имя файла, из которого читается информация, сохраняется в перемен-
# ной filename. Это стандартный прием при работе с файлами: так как переменная
# filename не представляет конкретный файл (это всего лишь строка, которая со-
# общает Python, где найти файл), вы сможете легко заменить 'pi_digits.txt'
# именем другого файла, с которым вы собираетесь работать. После вызова open()
# объект, представляющий файл и его содержимое, сохраняется в переменной
# file_object . Мы снова используем синтаксис with, чтобы поручить Python
# открывать и закрывать файл в нужный момент. Для просмотра содержимого все
# строки файла перебираются в цикле for по объекту файла .
# На этот раз пустых строк оказывается еще больше:

# 3.1415926535
#
# 8979323846
#
# 2643383279


# Пустые строки появляются из-за того, что каждая строка в текстовом файле за-
# вершается невидимым символом новой строки. Команда print добавляет свой
# символ новой строки при каждом вызове, поэтому в результате каждая строка
# завершается двумя символами новой строки: один прочитан из файла, а другой
# добавлен командой print. Вызов rstrip() в команде print удаляет лишние пу-
# стые строки:


# file_name = ('D:\Python library\pi_digits.txt')
#
# with open(file_name) as file_object:
#     for line in file_object:
#         print(line.rstrip())


# ---------------------------------------------------------------------------------------------------------------------

# Создание списка строк по содержимому файла

# file_name = ('D:\Python library\pi_digits.txt')
#
# with open(file_name) as file_object:
#     lines = file_object.readline()   # 1
#     for line in lines:         # 2
#         print(line.rstrip())

# В точке  метод readlines() последовательно читает каждую строку из файла
# и сохраняет ее в списке. Список сохраняется в переменной lines, с которой можно
# продолжить работу после завершения блока with. В точке  в простом цикле for
# выводятся все элементы списка lines. Так как каждый элемент lines соответствует
# ровно одной строке файла, вывод точно соответствует его содержимому.

# ---------------------------------------------------------------------------------------------------------------------

# Работа с содержимым файла

# filename = ('D:\Python library\pi_digits.txt')
#
# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ''  # 1
#     for line in lines:  # 2
#         pi_string += line.rstrip()
#
#     print(pi_string)  # 3
#     print(len(pi_string))

# Сначала программа открывает файл и сохраняет каждую строку цифр в списке —
# точно так же, как это делалось в предыдущем примере. В точке  создается пере-
# менная pi_string для хранения цифр числа «пи». Далее следует цикл, который
# добавляет к pi_string каждую серию цифр, из которой удаляется символ новой
# строки . В точке  программа выводит строку и ее длину:

# Переменная pi_string содержит пропуски, которые присутствовали в начале
# каждой строки цифр. Чтобы удалить их, достаточно использовать strip() вместо
# rstrip():

# В итоге мы получаем строку, содержащую значение «пи» с точностью до 30 знаков.
# Длина строки равна 32 символам, потому что в нее также включается начальная
# цифра 3 и точка:
# 3.141592653589793238462643383279
# 32

# --------------------------------------------------------------------------------------------------------------------

# Большие файлы: миллион цифр

# filename = ('D:\Python library\pi_million_digits.txt')
#
# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ''  # 1
#     for line in lines:  # 2
#         pi_string += line.rstrip()
#
#     print(pi_string[:52] + '...')  # 3
#     print(len(pi_string))

# -------------------------------------------------------------------------------------------------------------------

# Проверка дня рождения

# Меня всегда интересовало, не встречается ли мой день рождения среди цифр числа
# «пи»? Воспользуемся только что созданной программой для проверки того, входит
# ли запись дня рождения пользователя в первый миллион цифр. Для этого можно
# записать день рождения в виде строки из цифр и посмотреть, присутствует ли эта
# строка в pi_string:

# filename = ('D:\Python library\pi_million_digits.txt')

# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ""
#     for line in lines:
#         pi_string += line.rstrip()
#
# birthday = input("Введите свой день рождения в форму ddmmyy:")
# if birthday in pi_string:
#     print("Ваш день рождения отображается в первом миллионе цифр числа Пи.")
# else:
#     print("Ваш день рождения не появляется в первом миллионе цифр числа Пи.")

# ---------------------------------------------------------------------------------------------------------------------

# 10-1. Изучение Python: откройте пустой файл в текстовом редакторе и напишите несколько
# строк текста о возможностях Python. Каждая строка должна начинаться с фразы: «In Python
# you can…» Сохраните файл под именем learning_python.txt в каталоге, использованном для
# примеров этой главы. Напишите программу, которая читает файл и выводит текст три раза:
# с чтением всего файла, с перебором строк объекта файла и с сохранением строк в списке
# с последующим выводом списка вне блока with.

# file = ("D:\Python library\learning_python.txt")
#
# print("--- Чтение всего файла:")
# with open(file) as file_object:
#     text = file_object.read()
#     print(text.rstrip())
#
# print("\n--- Сохранение строк в списке:")
# with open(file) as file_object:
#     lines = file_object.readlines()
#     for line in lines:
#         print(file.rstrip())

# print("\n--- Цикл по линиям:")
# with open(file) as file_object:
#     for file in file_object:
#         print(file.rstrip())

# --------------------------------------------------------------------------------------------------------------------

# 10-2. Изучение C: метод replace() может использоваться для замены любого слова в строке
# другим словом. В следующем примере слово ‘dog’ заменяется словом ‘cat’:
# >>> message = "I really like dogs."
# >>> message.replace('dog', 'cat')
# 'I really like cats.'
# Прочитайте каждую строку из только что созданного файла learning_python.txt и замените
# слово Python названием другого языка, например C. Выведите каждую измененную строку
# на экран.

# file = ("E:\python library\learning_python.txt")
#
# with open(file) as file_object:
#     files = file_object.readlines()
#     for file in files:
#         print(file.replace("Python", "C").rstrip())


# --------------------------------------------------------------------------------------------------------------------

# Запись в файл

# Один из простейших способов сохранения данных — запись в файл. Текст,
# записанный в файл, останется доступным и после закрытия терминала с выводом вашей программы.
# Вы сможете проанализировать результаты после
# завершения программы или передать свои файлы другим. Вы также сможете
# написать программы, которые снова читают сохраненный текст в память и работают с ним.

# ---------------------------------------------------------------------------------------------------------------------

# Запись в пустой файл

# Чтобы записать текст в файл, необходимо вызвать open() со вторым аргументом,
# который сообщает Python, что вы собираетесь записывать данные в файл. Чтобы
# увидеть, как это делается, напишем простое сообщение и сохраним его в файле
# (вместо того чтобы просто вывести на экран):

# filename = ("D:\Python library\learning_python.txt")

# with open(filename, "w") as file_object:       # 1
#     file_object.write("I love programming.")   # 2

# При вызове open() в этом примере передаются два аргумента . Первый аргумент,
# как и прежде, содержит имя открываемого файла. Второй аргумент 'w' сообщает
# Python, что файл должен быть открыт в режиме записи. Файлы можно открывать
# в режиме чтения ('r'), записи ('w'), присоединения ('a') или в режиме, допуска-
# ющем как чтение, так и запись в файл ('r+'). Если аргумент режима не указан,
# Python по умолчанию открывает файл в режиме только для чтения.
# Если файл, открываемый для записи, еще не существует, функция open() автома-
# тически создает его. Будьте внимательны, открывая файл в режиме записи ('w'):
# если файл существует, то Python уничтожит его данные перед возвращением
# объекта файла.
# В точке  метод write() используется с объектом файла для записи строки в файл.
# Программа не выводит данные на терминал, но, открыв файл programming.txt, вы
# увидите в нем одну строку:

# I love programming.

# ПРИМЕЧАНИЕ
# Python может записывать в текстовые файлы только строковые данные. Если вы захотите сохра-
# нить в текстовом файле числовую информацию, данные придется предварительно преобразовать
# в строки функцией str().

# --------------------------------------------------------------------------------------------------------------------

# Многострочная запись

# Функция write() не добавляет символы новой строки в записываемый текст. А это
# означает, что если вы записываете сразу несколько строк без включения символов
# новой строки, полученный файл может выглядеть не так, как вы рассчитывали:

# filename = ("D:\Python library\learning_python.txt")
#
# with open(filename, "w") as file_object:
#     file_object.write("I love programming.")
#     file_object.write("I love creating new games.")

# Открыв файл , вы увидите, что две строки «склеились»:
# I love programming.I love creating new games.
# Если включить символы новой строки в команды write(), текст будет состоять
# из двух строк:


# filename = ("D:\Python library\learning_python.txt")
#
# with open(filename, 'w') as file_object:
#     file_object.write("I love programming.\n")
#     file_object.write("I love creating new games.\n")


# Результат выглядит так:
# I love programming.
# I love creating new games.
# Для форматирования вывода также можно использовать пробелы, символы табу-
# ляции и пустые строки по аналогии с тем, как это делалось с выводом на терминал.

# --------------------------------------------------------------------------------------------------------------------

# Присоединение данных к файлу

# filename = ("D:\Python library\learning_python.txt")
#
# with open (filename, "a") as file_object:    # 1
#     file_object.write("I also love finding meaning in large datasets.\n")    # 2
#     file_object.write("I love creating apps that can run in a browser.\n")

# В точке  аргумент 'a' используется для открытия файла в режиме присоединения
# (вместо перезаписи существующего файла). В точке  записываются две новые
# строки, которые добавляются к содержимому


# I love programming.
# I love creating new games.
# I also love finding meaning in large datasets.
# I love creating apps that can run in a browser.

# В результате к исходному содержимому файла добавляется новый текст.

# ---------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 10-3. Гость: напишите программу, которая запрашивает у пользователя его имя. Введенный
# ответ сохраняется в файле с именем guest.txt.


# names = input("What is you name?\t")
# filename = ("D:\Python library\he_task.txt")
#
# with open(filename, "w") as file_object:
#     file_object.write(names)

# ---------------------------------------------------------------------------------------------------------------------

# 10-4. Гостевая книга: напишите цикл while, который в цикле запрашивает у пользователей
# имена. При вводе каждого имени выведите на экран приветствие и добавьте строку с со-
# общением в файл с именем guest_book.txt. Проследите за тем, чтобы каждое сообщение
# размещалось в отдельной строке файла.


# filename = ("D:\Python library\he_task.txt")
#
# print("Когда закончите введите quit")
#
# while True:
#     name = input("Введите своё имя: ")
#     if name == "quit":
#         break
#     else:
#         with open(filename, "a") as f:
#             f.write(name + "\n")
#         print("Првиет " + name + " ,вы добавлены в гостевую книгу.")

# --------------------------------------------------------------------------------------------------------------------

# 10-5. Опрос: напишите цикл while, в котором программа спрашивает у пользователя, по-
# чему ему нравится программировать. Каждый раз, когда пользователь вводит очередную
# причину, сохраните текст его ответа в файле.


# filename = ("D:\Python library\he_task.txt")
#
#
# book_names = []
# while True:
#     names = input("\nПочему тебе нравится программирование:\t")
#     book_names.append(names + "\n")
#
#     continue_poll = input("Вы бы хотели, чтобы кто-то другой ответил?? (y/n) ")
#     if continue_poll == "y":
#         break
#
#     with open(filename, "a") as f:
#         f.write(names + "\n")

# --------------------------------------------------------------------------------------------------------------------

# Исключения
# Для управления ошибками, возникающими в ходе выполнения программы,
# в Python используются специальные объекты, называемые исключениями. Если
# при возникновении ошибки Python не знает, что делать дальше, создается объект
# исключения. Если в программу включен код обработки исключения, то выполне-
# ние программы продолжится, а если нет — программа останавливается и выводит
# трассировку с отчетом об исключении.
# Исключения обрабатываются в блоках try-except. Блок try-except приказывает
# Python выполнить некоторые действия, но при этом также сообщает, что нужно де-
# лать при возникновении
# исключения. С блоками try-except ваши программы будут
# работать даже в том случае, если что-то пошло не так. Вместо невразумительной
# трассировки выводится понятное сообщение об ошибке, которое вы определяете
# в программе.

# --------------------------------------------------------------------------------------------------------------------

# Обработка исключения ZeroDivisionError
# Рассмотрим простую ошибку, при которой Python инициирует исключение. Ко-
# нечно, вы знаете, что деление на ноль невозможно, но мы все же прикажем Python
# выполнить эту операцию:
# division.py

# print(5/0)

# Из этого ничего не выйдет, поэтому на экран выводятся данные трассировки:
# Traceback (most recent call last):
# File "division.py", line 1, in <module>
# print(5/0)
#  ZeroDivisionError: division by zero
# Ошибка, упоминаемая в трассировке  — ZeroDivisionError, — является объектом
# исключения. Такие объекты создаются в том случае, если Python не может выпол-
# нить ваши распоряжения. Обычно в таких случаях Python прерывает выполнение
# программы и сообщает тип обнаруженного исключения. Эта информация может
# использоваться в программе; по сути вы сообщаете Python, как следует поступить
# при возникновении исключения данного типа. В таком случае ваша программа
# будет подготовлена к его появлению.

# ---------------------------------------------------------------------------------------------------------------------

# Блоки try-except
# Если вы предполагаете, что в программе может произойти ошибка, напишите блок
# try-except для обработки возникающего исключения. Такой блок приказывает
# Python выполнить некоторый код, а также сообщает, что нужно делать, если при
# его выполнении произойдет исключение конкретного типа.
# Вот как выглядит блок try-except для обработки исключений ZeroDivisionError:

# try:
#     print(5/0)
# except ZeroDivisionError:
#     print("Вы не можете делить на ноль!")

# Команда print(5/0), порождающая ошибку, находится в блоке try. Если код в бло-
# ке try выполнен успешно, то Python пропускает блок except. Если код в блоке
# try порождает ошибку, то Python ищет блок except с соответствующей ошибкой
# и выпускает код в этом блоке.
# В этом примере код блока try порождает ошибку ZeroDivisionError, поэтому
# Python ищет блок except с описанием того, как следует действовать в такой ситу-
# ации. При выполнении кода этого блока пользователь видит понятное сообщение
# об ошибке вместо данных трассировки:
# You can't divide by zero!
# Если бы за кодом try-except следовал другой код, то выполнение программы
# продолжилось, потому что мы объяснили Python, как обрабатывать эту ошибку.
# В следующем примере обработка ошибки позволяет программе продолжить вы-
# полнение.

# --------------------------------------------------------------------------------------------------------------------

# Использование исключений для предотвращения аварийного
# завершения программы

# Правильная обработка ошибок особенно важна в том случае, если программа
# должна продолжить работу после возникновения ошибки. Такая ситуация часто
# встречается в программах, запрашивающих данные у пользователя. Если програм-
# ма правильно среагировала на некорректный ввод, она может запросить новые
# данные после сбоя.
# Создадим простой калькулятор, который выполняет только операцию деления:


# print("Дай мне два числа, и я разделю их.")
# print("Введите 'q' чтобы выйти.")
# while True:
#     print("Дай мне два числа, и я разделю их.")
#     print("Введите 'q' чтобы выйти.")
#     first_number = input("\nПервый номер: ")
#     if first_number == 'q':
#         break
#     second_number = input("Второй номер: ")
#     if second_number == 'q':
#         break
#     answer = int(first_number) / int(second_number)
#     print("Ответ: " + str(answer) + "\n")
