# Файлы и исключения

# Чтение из файла

# Гигантские объемы данных доступны в текстовых файлах. В них могут храниться
# погодные данные, социально-экономическая информация, литературные произ-
# ведения и многое другое. Чтение из файла особенно актуально для приложений,
# предназначенных для анализа данных, но оно также может пригодиться в любой
# ситуации, требующей анализа или изменения информации, хранящейся в фай-
# ле. Например, программа может читать содержимое текстового файла и пере-
# писывать его с форматированием, рассчитанным на отображение информации
# в браузере.
# Работа с информацией в текстовом файле начинается с чтения данных в память.
# Вы можете прочитать все содержимое файла или же читать данные по строкам.

# --------------------------------------------------------------------------------------------------------------------

# Чтение всего файла

# Для начала нам понадобится файл с несколькими строками текста. Пусть это будет
# файл с числом «пи» с точностью до 30 знаков, по 10 знаков на строку:

# 3.1415926535
# 8979323846
# 2643383279

# Чтобы опробовать эти примеры, либо введите данные в редакторе и сохраните файл
# с именем pi_digits.txt, либо загрузите файл из ресурсов книги на странице https://
# www.nostarch.com/pythoncrashcourse/. Сохраните файл в каталоге, в котором будут
# храниться программы этой главы.
# Следующая программа открывает этот файл, читает его и выводит содержимое
# на экран:

# with open('D:\Python library\pi_digits.txt') as file_object:
#     contents = file_object.read()
#     print(contents)


# В первой строке этой программы многое заслуживает вашего внимания. Начнем
# с функции open(). Чтобы выполнить любые операции с файлом — даже просто
# вывести его содержимое, — сначала необходимо открыть файл. Функция open()
# получает один аргумент: имя открываемого файла. Python ищет файл с указанным
# именем в каталоге, в котором находится файл текущей программы. В данном при-
# мере выполняется программа file_reader.py, поэтому Python ищет файл pi_digits.txt
# в каталоге, в котором хранится file_reader.py. Функция open() возвращает объект,
# представляющий файл. В данном случае open('pi_digits.txt') возвращает объ-
# ект, представляющий файл pi_digits.txt. Python сохраняет этот объект в переменной
# file_object, с которой мы будем работать позднее в программе.
# Конструкция с ключевым словом with закрывает файл после того, как надобность
# в нем отпадет. Обратите внимание: в этой программе есть вызов open(), но нет
# вызова close(). Файлы можно открывать и закрывать явными вызовами open()
# и close(); но если из-за ошибки в программе команда close() останется невыпол-
# ненной, то файл не будет закрыт. На первый взгляд это не страшно, но некоррект-
# ное закрытие файлов может привести к потере или порче данных. А если функция
# close() будет вызвана слишком рано, программа попытается работать с закрытым
# (то есть недоступным) файлом, что приведет к новым ошибкам. Не всегда можно
# заранее определить, когда нужно закрывать файл, но с приведенной конструкцией
# Python сделает это за вас. Вам остается лишь открыть файл и работать с ним так,
# как требуется, надеясь на то, что Python закроет его автоматически в правильный
# момент.
# После того как в программе появится объект, представляющий файл pi_digits.txt, во
# второй строке программы используется метод read(), который читает все содер-
# жимое файла и сохраняет его содержимое в одной длинной строке в переменной
# Чтение из файла 187
# contents. При выводе значения contents на экране появляется все содержимое
# файла :

# 3.1415926535
# 8979323846
# 2643383279

# Единственное различие между выводом и исходным файлом — лишняя пустая
# строка в конце вывода. Откуда она взялась? Метод read() возвращает ее при чте-
# нии, если достигнут конец файла. Если вы хотите удалить лишнюю пустую строку,
# включите вызов rstrip() в команду print:

# with open('D:\Python library\pi_digits.txt') as file_object:
#     contents = file_object.read()
#     print(contents.rstrip())

# Напомним, что метод rstrip() удаляет все пропуски в конце строки. Теперь вывод
# точно соответствует содержимому исходного файла:

# --------------------------------------------------------------------------------------------------------------------

# Пути к файлам

# Если передать функции open() простое имя файла, такое как pi_digits.txt, Python
# ищет файл в том каталоге, в котором находится файл, выполняемый в настоящий
# момент (то есть файл программы .py).
# В некоторых случаях (в зависимости от того, как организованы ваши рабочие фай-
# лы) открываемый файл может и не находиться в одном каталоге с файлом програм-
# мы. Например, файл программы может находиться в каталоге python_work; в ката-
# логе python_work создается другой каталог с именем text_files для текстовых файлов,
# с которыми работает программа. И хотя папка text_files находится в python_work,
# простая передача open() имени файла из text_files не подойдет, потому что Python
# проведет поиск файла в python_work и на этом остановится; поиск не будет продол-
# жен во вложенном каталоге text_files. Чтобы открыть файлы из каталога, отличного
# от того, в котором хранится файл программы, необходимо указать путь — то есть
# приказать Python искать файлы в конкретном месте файловой системы.
# Так как каталог text_files находится в python_work, для открытия файла из text_files
# можно воспользоваться относительным путем. Относительный путь приказы-
# вает Python искать файлы в каталоге, который задается относительно каталога,
# в котором находится текущий файл программы. В системе Linux и OS X это вы-
# глядит так:
# with open('text_files/имя_файла.txt') as file_object:
# Эта строка означает, что файл .txt следует искать в каталоге text_files; она предпо-
# лагает, что каталог text_files находится в python_work (так оно и есть). В системах
# Windows в путях к файлам вместо слеша (/) используется обратный слеш (\):
# with open('text_files\имя_файла.txt') as file_object:
# 188 Глава 10 • Файлы и исключения
# Также можно точно определить местонахождение файла в вашей системе неза-
# висимо от того, где хранится выполняемая программа. Такие пути называются
# абсолютными и используются в том случае, если относительный путь не работает.
# Например, если каталог text_files находится не в python_work, а в другом каталоге
# (скажем, в каталоге с именем other_files), то передать open() путь 'text_files/
# filename.txt' не получится, потому что Python будет искать указанный каталог
# только внутри python_work. Чтобы объяснить Python, где следует искать файл, не-
# обходимо записать полный путь.
# Абсолютные пути обычно длиннее относительных, поэтому их лучше сохранять
# в переменных, которые затем передаются open(). В Linux и OS X абсолютные пути
# выглядят так:
# file_path = '/home/ehmatthes/other_files/text_files/имя_файла.txt'
# with open(file_path) as file_object:
# В Windows они выглядят так:
# file_path = 'C:\Users\ehmatthes\other_files\text_files\имя_файла.txt'
# with open(file_path) as file_object:
# С абсолютными путями вы сможете читать файлы из любого каталога вашей си-
# стемы. Пока будет проще хранить файлы в одном каталоге с файлами программ
# или в каталогах, вложенных в каталог с файлами программ (таких как text_files из
# рассмотренного примера).
# ПРИМЕЧАНИЕ
# Иногда в системах семейства Windows слеш в пути к файлам интерпретируется правильно. Если вы
# используете Windows, но не получаете ожидаемых результатов, попробуйте использовать символы
# обратного слеша.

# --------------------------------------------------------------------------------------------------------------------

# Чтение по строкам

# file_name = ('D:\Python library\pi_digits.txt')  # 1
#
# with open(file_name) as file_object:    # 2
#     for line in file_object:   # 3
#         print(line)


# В точке  имя файла, из которого читается информация, сохраняется в перемен-
# ной filename. Это стандартный прием при работе с файлами: так как переменная
# filename не представляет конкретный файл (это всего лишь строка, которая со-
# общает Python, где найти файл), вы сможете легко заменить 'pi_digits.txt'
# именем другого файла, с которым вы собираетесь работать. После вызова open()
# объект, представляющий файл и его содержимое, сохраняется в переменной
# file_object . Мы снова используем синтаксис with, чтобы поручить Python
# открывать и закрывать файл в нужный момент. Для просмотра содержимого все
# строки файла перебираются в цикле for по объекту файла .
# На этот раз пустых строк оказывается еще больше:

# 3.1415926535
#
# 8979323846
#
# 2643383279


# Пустые строки появляются из-за того, что каждая строка в текстовом файле за-
# вершается невидимым символом новой строки. Команда print добавляет свой
# символ новой строки при каждом вызове, поэтому в результате каждая строка
# завершается двумя символами новой строки: один прочитан из файла, а другой
# добавлен командой print. Вызов rstrip() в команде print удаляет лишние пу-
# стые строки:


# file_name = ('D:\Python library\pi_digits.txt')
#
# with open(file_name) as file_object:
#     for line in file_object:
#         print(line.rstrip())


# ---------------------------------------------------------------------------------------------------------------------

# Создание списка строк по содержимому файла

# file_name = ('D:\Python library\pi_digits.txt')
#
# with open(file_name) as file_object:
#     lines = file_object.readline()   # 1
#     for line in lines:         # 2
#         print(line.rstrip())

# В точке  метод readlines() последовательно читает каждую строку из файла
# и сохраняет ее в списке. Список сохраняется в переменной lines, с которой можно
# продолжить работу после завершения блока with. В точке  в простом цикле for
# выводятся все элементы списка lines. Так как каждый элемент lines соответствует
# ровно одной строке файла, вывод точно соответствует его содержимому.

# ---------------------------------------------------------------------------------------------------------------------

# Работа с содержимым файла

# filename = ('D:\Python library\pi_digits.txt')
#
# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ''  # 1
#     for line in lines:  # 2
#         pi_string += line.rstrip()
#
#     print(pi_string)  # 3
#     print(len(pi_string))

# Сначала программа открывает файл и сохраняет каждую строку цифр в списке —
# точно так же, как это делалось в предыдущем примере. В точке  создается пере-
# менная pi_string для хранения цифр числа «пи». Далее следует цикл, который
# добавляет к pi_string каждую серию цифр, из которой удаляется символ новой
# строки . В точке  программа выводит строку и ее длину:

# Переменная pi_string содержит пропуски, которые присутствовали в начале
# каждой строки цифр. Чтобы удалить их, достаточно использовать strip() вместо
# rstrip():

# В итоге мы получаем строку, содержащую значение «пи» с точностью до 30 знаков.
# Длина строки равна 32 символам, потому что в нее также включается начальная
# цифра 3 и точка:
# 3.141592653589793238462643383279
# 32

# --------------------------------------------------------------------------------------------------------------------

# Большие файлы: миллион цифр

# filename = ('D:\Python library\pi_digits.txt')
#
# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ''  # 1
#     for line in lines:  # 2
#         pi_string += line.rstrip()
#
#     print(pi_string[:52] + '...')  # 3
#     print(len(pi_string))

# -------------------------------------------------------------------------------------------------------------------

# Проверка дня рождения

# Меня всегда интересовало, не встречается ли мой день рождения среди цифр числа
# «пи»? Воспользуемся только что созданной программой для проверки того, входит
# ли запись дня рождения пользователя в первый миллион цифр. Для этого можно
# записать день рождения в виде строки из цифр и посмотреть, присутствует ли эта
# строка в pi_string:

