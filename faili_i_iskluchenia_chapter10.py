# Файлы и исключения

# Чтение из файла

# Гигантские объемы данных доступны в текстовых файлах. В них могут храниться
# погодные данные, социально-экономическая информация, литературные произ-
# ведения и многое другое. Чтение из файла особенно актуально для приложений,
# предназначенных для анализа данных, но оно также может пригодиться в любой
# ситуации, требующей анализа или изменения информации, хранящейся в фай-
# ле. Например, программа может читать содержимое текстового файла и пере-
# писывать его с форматированием, рассчитанным на отображение информации
# в браузере.
# Работа с информацией в текстовом файле начинается с чтения данных в память.
# Вы можете прочитать все содержимое файла или же читать данные по строкам.

# --------------------------------------------------------------------------------------------------------------------

# Чтение всего файла

# Для начала нам понадобится файл с несколькими строками текста. Пусть это будет
# файл с числом «пи» с точностью до 30 знаков, по 10 знаков на строку:

# 3.1415926535
# 8979323846
# 2643383279

# Чтобы опробовать эти примеры, либо введите данные в редакторе и сохраните файл
# с именем pi_digits.txt, либо загрузите файл из ресурсов книги на странице https://
# www.nostarch.com/pythoncrashcourse/. Сохраните файл в каталоге, в котором будут
# храниться программы этой главы.
# Следующая программа открывает этот файл, читает его и выводит содержимое
# на экран:

# with open('D:\Python library\pi_digits.txt') as file_object:
#     contents = file_object.read()
#     print(contents)


# В первой строке этой программы многое заслуживает вашего внимания. Начнем
# с функции open(). Чтобы выполнить любые операции с файлом — даже просто
# вывести его содержимое, — сначала необходимо открыть файл. Функция open()
# получает один аргумент: имя открываемого файла. Python ищет файл с указанным
# именем в каталоге, в котором находится файл текущей программы. В данном при-
# мере выполняется программа file_reader.py, поэтому Python ищет файл pi_digits.txt
# в каталоге, в котором хранится file_reader.py. Функция open() возвращает объект,
# представляющий файл. В данном случае open('pi_digits.txt') возвращает объ-
# ект, представляющий файл pi_digits.txt. Python сохраняет этот объект в переменной
# file_object, с которой мы будем работать позднее в программе.
# Конструкция с ключевым словом with закрывает файл после того, как надобность
# в нем отпадет. Обратите внимание: в этой программе есть вызов open(), но нет
# вызова close(). Файлы можно открывать и закрывать явными вызовами open()
# и close(); но если из-за ошибки в программе команда close() останется невыпол-
# ненной, то файл не будет закрыт. На первый взгляд это не страшно, но некоррект-
# ное закрытие файлов может привести к потере или порче данных. А если функция
# close() будет вызвана слишком рано, программа попытается работать с закрытым
# (то есть недоступным) файлом, что приведет к новым ошибкам. Не всегда можно
# заранее определить, когда нужно закрывать файл, но с приведенной конструкцией
# Python сделает это за вас. Вам остается лишь открыть файл и работать с ним так,
# как требуется, надеясь на то, что Python закроет его автоматически в правильный
# момент.
# После того как в программе появится объект, представляющий файл pi_digits.txt, во
# второй строке программы используется метод read(), который читает все содер-
# жимое файла и сохраняет его содержимое в одной длинной строке в переменной
# contents. При выводе значения contents на экране появляется все содержимое
# файла :

# 3.1415926535
# 8979323846
# 2643383279

# Единственное различие между выводом и исходным файлом — лишняя пустая
# строка в конце вывода. Откуда она взялась? Метод read() возвращает ее при чте-
# нии, если достигнут конец файла. Если вы хотите удалить лишнюю пустую строку,
# включите вызов rstrip() в команду print:

# with open('D:\Python library\pi_digits.txt') as file_object:
#     contents = file_object.read()
#     print(contents.rstrip())

# Напомним, что метод rstrip() удаляет все пропуски в конце строки. Теперь вывод
# точно соответствует содержимому исходного файла:

# --------------------------------------------------------------------------------------------------------------------

# Пути к файлам

# Если передать функции open() простое имя файла, такое как pi_digits.txt, Python
# ищет файл в том каталоге, в котором находится файл, выполняемый в настоящий
# момент (то есть файл программы .py).
# В некоторых случаях (в зависимости от того, как организованы ваши рабочие фай-
# лы) открываемый файл может и не находиться в одном каталоге с файлом програм-
# мы. Например, файл программы может находиться в каталоге python_work; в ката-
# логе python_work создается другой каталог с именем text_files для текстовых файлов,
# с которыми работает программа. И хотя папка text_files находится в python_work,
# простая передача open() имени файла из text_files не подойдет, потому что Python
# проведет поиск файла в python_work и на этом остановится; поиск не будет продол-
# жен во вложенном каталоге text_files. Чтобы открыть файлы из каталога, отличного
# от того, в котором хранится файл программы, необходимо указать путь — то есть
# приказать Python искать файлы в конкретном месте файловой системы.
# Так как каталог text_files находится в python_work, для открытия файла из text_files
# можно воспользоваться относительным путем. Относительный путь приказы-
# вает Python искать файлы в каталоге, который задается относительно каталога,
# в котором находится текущий файл программы. В системе Linux и OS X это вы-
# глядит так:
# with open('text_files/имя_файла.txt') as file_object:
# Эта строка означает, что файл .txt следует искать в каталоге text_files; она предпо-
# лагает, что каталог text_files находится в python_work (так оно и есть). В системах
# Windows в путях к файлам вместо слеша (/) используется обратный слеш (\):
# with open('text_files\имя_файла.txt') as file_object:
# 188 Глава 10 • Файлы и исключения
# Также можно точно определить местонахождение файла в вашей системе неза-
# висимо от того, где хранится выполняемая программа. Такие пути называются
# абсолютными и используются в том случае, если относительный путь не работает.
# Например, если каталог text_files находится не в python_work, а в другом каталоге
# (скажем, в каталоге с именем other_files), то передать open() путь 'text_files/
# filename.txt' не получится, потому что Python будет искать указанный каталог
# только внутри python_work. Чтобы объяснить Python, где следует искать файл, не-
# обходимо записать полный путь.
# Абсолютные пути обычно длиннее относительных, поэтому их лучше сохранять
# в переменных, которые затем передаются open(). В Linux и OS X абсолютные пути
# выглядят так:
# file_path = '/home/ehmatthes/other_files/text_files/имя_файла.txt'
# with open(file_path) as file_object:
# В Windows они выглядят так:
# file_path = 'C:\Users\ehmatthes\other_files\text_files\имя_файла.txt'
# with open(file_path) as file_object:
# С абсолютными путями вы сможете читать файлы из любого каталога вашей си-
# стемы. Пока будет проще хранить файлы в одном каталоге с файлами программ
# или в каталогах, вложенных в каталог с файлами программ (таких как text_files из
# рассмотренного примера).
# ПРИМЕЧАНИЕ
# Иногда в системах семейства Windows слеш в пути к файлам интерпретируется правильно. Если вы
# используете Windows, но не получаете ожидаемых результатов, попробуйте использовать символы
# обратного слеша.

# --------------------------------------------------------------------------------------------------------------------

# Чтение по строкам

# file_name = ('D:\Python library\pi_digits.txt')  # 1
#
# with open(file_name) as file_object:    # 2
#     for line in file_object:   # 3
#         print(line)


# В точке  имя файла, из которого читается информация, сохраняется в перемен-
# ной filename. Это стандартный прием при работе с файлами: так как переменная
# filename не представляет конкретный файл (это всего лишь строка, которая со-
# общает Python, где найти файл), вы сможете легко заменить 'pi_digits.txt'
# именем другого файла, с которым вы собираетесь работать. После вызова open()
# объект, представляющий файл и его содержимое, сохраняется в переменной
# file_object . Мы снова используем синтаксис with, чтобы поручить Python
# открывать и закрывать файл в нужный момент. Для просмотра содержимого все
# строки файла перебираются в цикле for по объекту файла .
# На этот раз пустых строк оказывается еще больше:

# 3.1415926535
#
# 8979323846
#
# 2643383279


# Пустые строки появляются из-за того, что каждая строка в текстовом файле за-
# вершается невидимым символом новой строки. Команда print добавляет свой
# символ новой строки при каждом вызове, поэтому в результате каждая строка
# завершается двумя символами новой строки: один прочитан из файла, а другой
# добавлен командой print. Вызов rstrip() в команде print удаляет лишние пу-
# стые строки:


# file_name = ('D:\Python library\pi_digits.txt')
#
# with open(file_name) as file_object:
#     for line in file_object:
#         print(line.rstrip())


# ---------------------------------------------------------------------------------------------------------------------

# Создание списка строк по содержимому файла

# file_name = ('D:\Python library\pi_digits.txt')
#
# with open(file_name) as file_object:
#     lines = file_object.readline()   # 1
#     for line in lines:         # 2
#         print(line.rstrip())

# В точке  метод readlines() последовательно читает каждую строку из файла
# и сохраняет ее в списке. Список сохраняется в переменной lines, с которой можно
# продолжить работу после завершения блока with. В точке  в простом цикле for
# выводятся все элементы списка lines. Так как каждый элемент lines соответствует
# ровно одной строке файла, вывод точно соответствует его содержимому.

# ---------------------------------------------------------------------------------------------------------------------

# Работа с содержимым файла

# filename = ('D:\Python library\pi_digits.txt')
#
# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ''  # 1
#     for line in lines:  # 2
#         pi_string += line.rstrip()
#
#     print(pi_string)  # 3
#     print(len(pi_string))

# Сначала программа открывает файл и сохраняет каждую строку цифр в списке —
# точно так же, как это делалось в предыдущем примере. В точке  создается пере-
# менная pi_string для хранения цифр числа «пи». Далее следует цикл, который
# добавляет к pi_string каждую серию цифр, из которой удаляется символ новой
# строки . В точке  программа выводит строку и ее длину:

# Переменная pi_string содержит пропуски, которые присутствовали в начале
# каждой строки цифр. Чтобы удалить их, достаточно использовать strip() вместо
# rstrip():

# В итоге мы получаем строку, содержащую значение «пи» с точностью до 30 знаков.
# Длина строки равна 32 символам, потому что в нее также включается начальная
# цифра 3 и точка:
# 3.141592653589793238462643383279
# 32

# --------------------------------------------------------------------------------------------------------------------

# Большие файлы: миллион цифр

# filename = ('D:\Python library\pi_million_digits.txt')
#
# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ''  # 1
#     for line in lines:  # 2
#         pi_string += line.rstrip()
#
#     print(pi_string[:52] + '...')  # 3
#     print(len(pi_string))

# -------------------------------------------------------------------------------------------------------------------

# Проверка дня рождения

# Меня всегда интересовало, не встречается ли мой день рождения среди цифр числа
# «пи»? Воспользуемся только что созданной программой для проверки того, входит
# ли запись дня рождения пользователя в первый миллион цифр. Для этого можно
# записать день рождения в виде строки из цифр и посмотреть, присутствует ли эта
# строка в pi_string:

# filename = ('D:\Python library\pi_million_digits.txt')

# with open(filename) as file_object:
#     lines = file_object.readlines()
#
#     pi_string = ""
#     for line in lines:
#         pi_string += line.rstrip()
#
# birthday = input("Введите свой день рождения в форму ddmmyy:")
# if birthday in pi_string:
#     print("Ваш день рождения отображается в первом миллионе цифр числа Пи.")
# else:
#     print("Ваш день рождения не появляется в первом миллионе цифр числа Пи.")

# ---------------------------------------------------------------------------------------------------------------------

# 10-1. Изучение Python: откройте пустой файл в текстовом редакторе и напишите несколько
# строк текста о возможностях Python. Каждая строка должна начинаться с фразы: «In Python
# you can…» Сохраните файл под именем learning_python.txt в каталоге, использованном для
# примеров этой главы. Напишите программу, которая читает файл и выводит текст три раза:
# с чтением всего файла, с перебором строк объекта файла и с сохранением строк в списке
# с последующим выводом списка вне блока with.

# file = ("D:\Python library\learning_python.txt")
#
# print("--- Чтение всего файла:")
# with open(file) as file_object:
#     text = file_object.read()
#     print(text.rstrip())
#
# print("\n--- Сохранение строк в списке:")
# with open(file) as file_object:
#     lines = file_object.readlines()
#     for line in lines:
#         print(file.rstrip())

# print("\n--- Цикл по линиям:")
# with open(file) as file_object:
#     for file in file_object:
#         print(file.rstrip())

# --------------------------------------------------------------------------------------------------------------------

# 10-2. Изучение C: метод replace() может использоваться для замены любого слова в строке
# другим словом. В следующем примере слово ‘dog’ заменяется словом ‘cat’:
# >>> message = "I really like dogs."
# >>> message.replace('dog', 'cat')
# 'I really like cats.'
# Прочитайте каждую строку из только что созданного файла learning_python.txt и замените
# слово Python названием другого языка, например C. Выведите каждую измененную строку
# на экран.

# file = ("E:\python library\learning_python.txt")
#
# with open(file) as file_object:
#     files = file_object.readlines()
#     for file in files:
#         print(file.replace("Python", "C").rstrip())


# --------------------------------------------------------------------------------------------------------------------

# Запись в файл

# Один из простейших способов сохранения данных — запись в файл. Текст,
# записанный в файл, останется доступным и после закрытия терминала с выводом вашей программы.
# Вы сможете проанализировать результаты после
# завершения программы или передать свои файлы другим. Вы также сможете
# написать программы, которые снова читают сохраненный текст в память и работают с ним.

# ---------------------------------------------------------------------------------------------------------------------

# Запись в пустой файл

# Чтобы записать текст в файл, необходимо вызвать open() со вторым аргументом,
# который сообщает Python, что вы собираетесь записывать данные в файл. Чтобы
# увидеть, как это делается, напишем простое сообщение и сохраним его в файле
# (вместо того чтобы просто вывести на экран):

# filename = ("D:\Python library\learning_python.txt")

# with open(filename, "w") as file_object:       # 1
#     file_object.write("I love programming.")   # 2

# При вызове open() в этом примере передаются два аргумента . Первый аргумент,
# как и прежде, содержит имя открываемого файла. Второй аргумент 'w' сообщает
# Python, что файл должен быть открыт в режиме записи. Файлы можно открывать
# в режиме чтения ('r'), записи ('w'), присоединения ('a') или в режиме, допуска-
# ющем как чтение, так и запись в файл ('r+'). Если аргумент режима не указан,
# Python по умолчанию открывает файл в режиме только для чтения.
# Если файл, открываемый для записи, еще не существует, функция open() автома-
# тически создает его. Будьте внимательны, открывая файл в режиме записи ('w'):
# если файл существует, то Python уничтожит его данные перед возвращением
# объекта файла.
# В точке  метод write() используется с объектом файла для записи строки в файл.
# Программа не выводит данные на терминал, но, открыв файл programming.txt, вы
# увидите в нем одну строку:

# I love programming.

# ПРИМЕЧАНИЕ
# Python может записывать в текстовые файлы только строковые данные. Если вы захотите сохра-
# нить в текстовом файле числовую информацию, данные придется предварительно преобразовать
# в строки функцией str().

# --------------------------------------------------------------------------------------------------------------------

# Многострочная запись

# Функция write() не добавляет символы новой строки в записываемый текст. А это
# означает, что если вы записываете сразу несколько строк без включения символов
# новой строки, полученный файл может выглядеть не так, как вы рассчитывали:

# filename = ("D:\Python library\learning_python.txt")
#
# with open(filename, "w") as file_object:
#     file_object.write("I love programming.")
#     file_object.write("I love creating new games.")

# Открыв файл , вы увидите, что две строки «склеились»:
# I love programming.I love creating new games.
# Если включить символы новой строки в команды write(), текст будет состоять
# из двух строк:


# filename = ("D:\Python library\learning_python.txt")
#
# with open(filename, 'w') as file_object:
#     file_object.write("I love programming.\n")
#     file_object.write("I love creating new games.\n")


# Результат выглядит так:
# I love programming.
# I love creating new games.
# Для форматирования вывода также можно использовать пробелы, символы табу-
# ляции и пустые строки по аналогии с тем, как это делалось с выводом на терминал.

# --------------------------------------------------------------------------------------------------------------------

# Присоединение данных к файлу

# filename = ("D:\Python library\learning_python.txt")
#
# with open (filename, "a") as file_object:    # 1
#     file_object.write("I also love finding meaning in large datasets.\n")    # 2
#     file_object.write("I love creating apps that can run in a browser.\n")

# В точке  аргумент 'a' используется для открытия файла в режиме присоединения
# (вместо перезаписи существующего файла). В точке  записываются две новые
# строки, которые добавляются к содержимому


# I love programming.
# I love creating new games.
# I also love finding meaning in large datasets.
# I love creating apps that can run in a browser.

# В результате к исходному содержимому файла добавляется новый текст.

# ---------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 10-3. Гость: напишите программу, которая запрашивает у пользователя его имя. Введенный
# ответ сохраняется в файле с именем guest.txt.


# names = input("What is you name?\t")
# filename = ("D:\Python library\he_task.txt")
#
# with open(filename, "w") as file_object:
#     file_object.write(names)

# ---------------------------------------------------------------------------------------------------------------------

# 10-4. Гостевая книга: напишите цикл while, который в цикле запрашивает у пользователей
# имена. При вводе каждого имени выведите на экран приветствие и добавьте строку с со-
# общением в файл с именем guest_book.txt. Проследите за тем, чтобы каждое сообщение
# размещалось в отдельной строке файла.


# filename = ("D:\Python library\he_task.txt")
#
# print("Когда закончите введите quit")
#
# while True:
#     name = input("Введите своё имя: ")
#     if name == "quit":
#         break
#     else:
#         with open(filename, "a") as f:
#             f.write(name + "\n")
#         print("Првиет " + name + " ,вы добавлены в гостевую книгу.")

# --------------------------------------------------------------------------------------------------------------------

# 10-5. Опрос: напишите цикл while, в котором программа спрашивает у пользователя, по-
# чему ему нравится программировать. Каждый раз, когда пользователь вводит очередную
# причину, сохраните текст его ответа в файле.


# filename = ("D:\Python library\he_task.txt")
#
#
# book_names = []
# while True:
#     names = input("\nПочему тебе нравится программирование:\t")
#     book_names.append(names + "\n")
#
#     continue_poll = input("Вы бы хотели, чтобы кто-то другой ответил?? (y/n) ")
#     if continue_poll == "y":
#         break
#
#     with open(filename, "a") as f:
#         f.write(names + "\n")

# --------------------------------------------------------------------------------------------------------------------

# Исключения
# Для управления ошибками, возникающими в ходе выполнения программы,
# в Python используются специальные объекты, называемые исключениями. Если
# при возникновении ошибки Python не знает, что делать дальше, создается объект
# исключения. Если в программу включен код обработки исключения, то выполне-
# ние программы продолжится, а если нет — программа останавливается и выводит
# трассировку с отчетом об исключении.
# Исключения обрабатываются в блоках try-except. Блок try-except приказывает
# Python выполнить некоторые действия, но при этом также сообщает, что нужно де-
# лать при возникновении
# исключения. С блоками try-except ваши программы будут
# работать даже в том случае, если что-то пошло не так. Вместо невразумительной
# трассировки выводится понятное сообщение об ошибке, которое вы определяете
# в программе.

# --------------------------------------------------------------------------------------------------------------------

# Обработка исключения ZeroDivisionError
# Рассмотрим простую ошибку, при которой Python инициирует исключение. Ко-
# нечно, вы знаете, что деление на ноль невозможно, но мы все же прикажем Python
# выполнить эту операцию:
# division.py

# print(5/0)

# Из этого ничего не выйдет, поэтому на экран выводятся данные трассировки:
# Traceback (most recent call last):
# File "division.py", line 1, in <module>
# print(5/0)
#  ZeroDivisionError: division by zero
# Ошибка, упоминаемая в трассировке  — ZeroDivisionError, — является объектом
# исключения. Такие объекты создаются в том случае, если Python не может выпол-
# нить ваши распоряжения. Обычно в таких случаях Python прерывает выполнение
# программы и сообщает тип обнаруженного исключения. Эта информация может
# использоваться в программе; по сути вы сообщаете Python, как следует поступить
# при возникновении исключения данного типа. В таком случае ваша программа
# будет подготовлена к его появлению.

# ---------------------------------------------------------------------------------------------------------------------

# Блоки try-except
# Если вы предполагаете, что в программе может произойти ошибка, напишите блок
# try-except для обработки возникающего исключения. Такой блок приказывает
# Python выполнить некоторый код, а также сообщает, что нужно делать, если при
# его выполнении произойдет исключение конкретного типа.
# Вот как выглядит блок try-except для обработки исключений ZeroDivisionError:

# try:
#     print(5/0)
# except ZeroDivisionError:
#     print("Вы не можете делить на ноль!")

# Команда print(5/0), порождающая ошибку, находится в блоке try. Если код в бло-
# ке try выполнен успешно, то Python пропускает блок except. Если код в блоке
# try порождает ошибку, то Python ищет блок except с соответствующей ошибкой
# и выпускает код в этом блоке.
# В этом примере код блока try порождает ошибку ZeroDivisionError, поэтому
# Python ищет блок except с описанием того, как следует действовать в такой ситу-
# ации. При выполнении кода этого блока пользователь видит понятное сообщение
# об ошибке вместо данных трассировки:
# You can't divide by zero!
# Если бы за кодом try-except следовал другой код, то выполнение программы
# продолжилось, потому что мы объяснили Python, как обрабатывать эту ошибку.
# В следующем примере обработка ошибки позволяет программе продолжить вы-
# полнение.

# --------------------------------------------------------------------------------------------------------------------

# Использование исключений для предотвращения аварийного
# завершения программы

# Правильная обработка ошибок особенно важна в том случае, если программа
# должна продолжить работу после возникновения ошибки. Такая ситуация часто
# встречается в программах, запрашивающих данные у пользователя. Если програм-
# ма правильно среагировала на некорректный ввод, она может запросить новые
# данные после сбоя.
# Создадим простой калькулятор, который выполняет только операцию деления:


# print("Дай мне два числа, и я разделю их.")
# print("Введите 'q' чтобы выйти.")
# while True:
#     first_number = input("\nПервый номер: ")
#     if first_number == 'q':
#         break
#     second_number = input("Второй номер: ")
#     if second_number == 'q':
#         break
#     answer = int(first_number) / int(second_number)
#     print("Ответ: " + str(answer) + "\n")

# Программа запрашивает у пользователя первое число first_number , а затем,
# если пользователь не ввел q для завершения работы, запрашивает второе число
# second_number . Далее одно число делится на другое для получения результата
# answer . Программа никак не обрабатывает ошибки, так что попытка деления на
# ноль приводит к ее аварийному завершению:

# Конечно, аварийное завершение — это плохо, но еще хуже, если пользователь
# увидит данные трассировки. Неопытного пользователя они собьют с толку, а при
# сознательной попытке взлома злоумышленник сможет получить из них больше
# информации, чем вам хотелось бы. Например, он узнает имя файла программы
# и увидит некорректно работающую часть кода. На основании этой информации
# опытный хакер иногда может определить, какие атаки следует применять против
# вашего кода.

# --------------------------------------------------------------------------------------------------------------------

# Блок else

# Для повышения устойчивости программы к ошибкам можно заключить строку,
# выдающую ошибки, в блок try-except. Ошибка происходит в строке, выполняющей
# деление; следовательно, именно эту строку следует заключить в блок try-except.
# Данный пример также включает блок else. Любой код, зависящий от успешного
# выполнения блока try, размещается в блоке else:


# print("Give me two numbers, and I'll divide them.")
# print("Enter 'q' to quit.")
# while True:
#     first_number = input("\nПервый номер: ")
#     if first_number == 'q':
#         break
#     second_number = input("Второй номер: ")
#     try:    # 1
#         answer = int(first_number) / int(second_number)
#     except ZeroDivisionError:    # 2
#         print("Вы не можете разделить на 0!")
#     else:   # 3
#         print(answer)

# Программа пытается выполнить операцию деления в блоке try , который
# включает только код, способный породить ошибку. Любой код, зависящий
# от успешного выполнения блока try, добавляется в блок else. В данном случае,
# если операция деления выполняется успешно, блок else используется для вы-
# вода результата .
# Блок except сообщает Python, как следует поступать при возникновении ошибки
# ZeroDivisionError . Если при выполнении команды из блока try происходит
# ошибка, связанная с делением на 0, программа выводит понятное сообщение,
# которое объясняет пользователю, как избежать подобных ошибок. Выполнение
# программы продолжается, и пользователь не сталкивается с трассировкой:

# Блок try-except-else работает так: Python пытается выполнить код в блоке try.
# В блоках try следует размещать только тот код, при выполнении которого может
# возникнуть исключение. Иногда некоторый код должен выполняться только в том
# случае, если выполнение try прошло успешно; такой код размещается в блоке else.
# Блок except сообщает Python, что делать, если при выполнении кода try произо-
# шло определенное исключение. Заранее определяя вероятные источники ошибок,
# вы повышаете надежность своих программ, которые продолжают работать даже при
# вводе некорректных данных или при недоступности ресурсов. Ваш код оказывается
# защищенным от случайных ошибок пользователей и сознательных атак.

# ---------------------------------------------------------------------------------------------------------------------

# Обработка исключения FileNotFoundError

# Одна из стандартных проблем при работе с файлами — отсутствие необходимых
# файлов. Тот файл, который вам нужен, может находиться в другом месте, в имени
# файла может быть допущена ошибка, или файл может вообще не существовать.
# Все эти ситуации достаточно прямолинейно обрабатываются в блоках try-except.
# Попробуем прочитать данные из несуществующего файла. Следующая програм-
# ма пытается прочитать содержимое файла с текстом «Алисы в Стране чудес», но
# я не сохранил файл alice.txt в одном каталоге с файлом alice.py:


# Прочитать данные из несуществующего файла нельзя, поэтому Python выдает
# исключение:

# filename = ("alice.txt")
# try:
#     with open(filename) as f_obj:
#         contents = f_obj.read()
# except FileNotFoundError:
#     msg = ("Извините, файл " + filename + " не существует.")
#     print(msg)


# В последней строке трассировки упоминается FileNotFoundError: это исключение
# выдается в том случае, если Python не может найти открываемый файл. В данном
# примере функция open() порождает ошибку, и, чтобы обработать ее, блок try на-
# чинается перед строкой с вызовом open():


# В этом примере код блока try выдает исключение FileNotFoundError, поэто-
# му Python ищет блок except для этой ошибки. Затем выполняется код этого
# блока, в результате чего вместо трассировки выдается доступное сообщение
# об ошибке:

# Sorry, the file alice.txt does not exist.

# Если файл не существует, программе больше делать нечего, поэтому код обработ-
# ки ошибок почти ничего не добавляет в эту программу. Доработаем этот пример
# и посмотрим, как обработка исключений помогает при работе с несколькими
# файлами.

# --------------------------------------------------------------------------------------------------------------------

# Анализ текста

# Программа может анализировать текстовые файлы, содержащие целые книги.
# Многие классические произведения, ставшие общественным достоянием, доступны
# в виде простых текстовых файлов. Тексты, использованные в этом разделе, взяты
# с сайта проекта «Гутенберг» (http://gutenberg.org/). На этом сайте хранится под-
# борка литературных произведений, не защищенных авторским правом; это превос-
# ходный ресурс для разработчиков, которые собираются работать с литературными
# текстами в своих программных проектах.
# Прочитаем текст «Алисы в Стране чудес» и попробуем подсчитать количество слов
# в тексте. Мы воспользуемся методом split(), предназначенным для построения
# списка слов на основе строки. Вот как метод split() работает со строкой, содер-
# жащей только название книги:

# 199

# >>> title = "Alice in Wonderland"
# >>> title.split()
# ['Alice', 'in', 'Wonderland']

# Метод split() разделяет строку на части по всем позициям, в которых обнаружит
# пробел, и сохраняет все части строки в элементах списка. В результате создается
# список слов, входящих в строку (впрочем, вместе с некоторыми словами могут
# храниться знаки препинания). Для подсчета слов в книге мы воспользуемся вызо-
# вом split() для всего текста, а затем подсчитаем элементы списка, чтобы получить
# примерное количество слов в тексте:

# filename = ("d:\Python library\Alice_in_Wonderland.txt")
# try:
#     with open(filename) as f_obj:
#         contents = f_obj.read()
# except FileNotFoundError:
#     msg = ("Извините, файл " + filename + " не существует.")
#     print(msg)
# else:
#     # Подсчёт приблизительного количества строк в файле.
#     words = contents.split()  # 1
#     num_words = len(words)    # 2
#     print("Файл " + filename + " имеет около " + str(num_words) + " строк.")  # 3

# был выполнен без ошибок. В точке  программа загружает текст в переменную
# contents, которая теперь содержит весь текст в виде одной длинной строки и ис-
# пользует метод split() для получения списка всех слов в книге. Запрашивая
# длину этого списка при помощи функции len(), мы получаем неплохое при-
# ближенное значение количества слов в исходной строке . В точке  выводится
# сообщение с количеством слов, найденных в файле. Этот код помещен в блок
# else, потому что он должен выводиться только в случае успешного выполнения
# блока try. Выходные данные программы сообщают, сколько слов содержит файл
# alice.txt:
# The file alice.txt has about 29461 words.

# --------------------------------------------------------------------------------------------------------------------

# Работа с несколькими файлами

# Добавим еще несколько файлов с книгами для анализа. Но для начала переместим
# основной код программы в функцию с именем count_words(). Это упростит про-
# ведение анализа для нескольких книг:


# def count_words(filename):
#     """Подсчёт приблизительного количества строк в файле."""
#
#     try:
#         with open(filename) as f_obj:
#             contents = f_obj.read()
#     except FileNotFoundError:
#         msg = ("Извините, файл " + filename + " не существует.")
#         print(msg)
#     else:
#         # Подсчёт приблизительного количества строк в файле.
#         words = contents.split()  # 1
#         num_words = len(words)  # 2
#         print("Файл " + filename + " имеет около " + str(num_words) + " строк.")
#
#
# filename = 'd:\Python library\Alice_in_Wonderland.txt'
# count_words(filename)


# Бульшая часть кода не изменилась. Мы просто снабдили код отступом и пере-
# местили его в тело count_words(). Кроме того, комментарий был преобразован
# в строку документации .
# Теперь мы можем написать простой цикл для подсчета слов в любом тексте,
# который нужно проанализировать. Для этого имена анализируемых файлов со-
# храняются в списке, после чего для каждого файла в списке вызывается функ-
# ция count_words(). Мы попробуем подсчитать слова в «Алисе в Стране чудес»,
# «Сиддхартхе», «Моби Дике» и «Маленьких женщинах» — все эти книги есть
# в свободном доступе. Я намеренно не стал копировать файл siddhartha.txt в каталог
# с программой word_count.py, чтобы выяснить, насколько хорошо наша программа
# справляется с отсутствием файла:

# def count_words(filename):
#     """Подсчёт приблизительного количества строк в файле."""
#
#     try:
#         with open(filename) as f_obj:
#             contents = f_obj.read()
#     except FileNotFoundError:
#         msg = ("Извините, файл " + filename + " не существует.")
#         print(msg)
#     else:
#         # Подсчёт приблизительного количества строк в файле.
#         words = contents.split()  # 1
#         num_words = len(words)  # 2
#         print("Файл " + filename + " имеет около " + str(num_words) + " строк.")
#
#
# filenames = ['d:\Python library\Alice_in_Wonderland.txt',
#              'siddhartha.txt',
#              'moby_dick.txt',
#              'little_women.txt']
# for filename in filenames:
#     count_words(filename)

# Отсутствие файла  не влияет на выполнение программы:

# Файл d:\Python library\Alice_in_Wonderland.txt имеет около 17842 строк.
# Извините, файл siddhartha.txt не существует.
# Извините, файл moby_dick.txt не существует.
# Извините, файл little_women.txt не существует.
# Использование блока try-except в этом примере дает два важных преимущества:
# программа ограждает пользователя от вывода трассировки и продолжает выполне-
# ние, анализируя тексты, которые ей удается найти. Если бы в программе не пере-
# хватывалось исключение FileNotFoundError, инициированное из-за отсутствия
# siddhartha.txt, то пользователь увидел бы полную трассировку, а работа программы
# прервалась бы после попытки подсчитать слова в тексте «Сиддхартхи»; до анализа
# «Моби Дика» или «Маленьких женщин» дело не дошло бы.

# ----------------------------------------------------------------------------------------------------------------------

# Ошибки без уведомления пользователя

# В предыдущем примере мы сообщили пользователю о том, что один из файлов ока-
# зался недоступен. Тем не менее вы не обязаны сообщать о каждом обнаруженном
# исключении. Иногда при возникновении исключения программа должна просто
# проигнорировать сбой и продолжать работу, словно ничего не произошло. Для
# этого блок try пишется так же, как обычно, но в блоке except вы явно приказыва-
# ете Python не предпринимать никаких особых действий в случае ошибки. В языке
# Python существует команда pass, с которой блок ничего не делает:

# def count_words(filename):
#     """Подсчёт приблизительного количества строк в файле."""
#
#     try:
#         with open(filename) as f_obj:
#             contents = f_obj.read()
#     except FileNotFoundError:
#         pass  # 1
#     else:
#         # Подсчёт приблизительного количества строк в файле.
#         words = contents.split()  # 1
#         num_words = len(words)  # 2
#         print("Файл " + filename + " имеет около " + str(num_words) + " строк.")
#
#
# filenames = ['d:\Python library\Alice_in_Wonderland.txt',
#              'siddhartha.txt',
#              'moby_dick.txt',
#              'little_women.txt']
# for filename in filenames:
#     count_words(filename)

# Единственное отличие этого листинга от предыдущего — команда pass в точке .
# Теперь при возникновении ошибки FileNotFoundError выполняется код в блоке
# except, но при этом ничего не происходит. Программа не выдает данные трасси-
# ровки и вообще никакие результаты, указывающие на возникновение ошибки.
# Пользователи получают данные о количестве слов во всех существующих файлах,
# однако ничто не сообщает о том, что какой-то файл не был найден:
#
#
# Файл d:\Python library\Alice_in_Wonderland.txt имеет около 17842 строк.

# Команда pass также может служить временным заполнителем. Она напоминает,
# что в этот конкретный момент выполнения вашей программы вы решили ниче-
# го не предпринимать, хотя, возможно, сделаете что-то позднее. Например, эта
# программа может записать все имена отсутствующих файлов в файл с именем
# missing_files.txt. Пользователи этот файл не увидят, но создатель программы сможет
# прочитать его и разобраться с отсутствующими текстами.

# --------------------------------------------------------------------------------------------------------------------

# О каких ошибках нужно сообщать?

# Как определить, в каком случае следует сообщить об ошибке пользователю, а когда
# можно просто проигнорировать ее незаметно для пользователя? Если пользователь
# знает, с какими текстами должна работать программа, вероятно, он предпочтет по-
# лучить сообщение, объясняющее, почему некоторые тексты были пропущены при
# анализе. Пользователь ожидает увидеть какие-то результаты, но не знает, какие
# книги должны быть проанализированы? Возможно, ему и не нужно знать о недо-
# ступности каких-то файлов. Лишняя информация только сделает вашу программу
# менее удобной для пользователя. Средства обработки ошибок Python позволяют
# достаточно точно управлять тем, какой объем информации следует предоставить
# пользователю.
# Хорошо написанный, правильно протестированный код редко содержит внутрен-
# ние ошибки (например, синтаксические или логические). Но в любой ситуации,
# в которой ваша программа зависит от внешних факторов (пользовательского ввода,
# существования файла, доступности сетевого подключения), существует риск воз-
# никновения исключения. С накоплением практического опыта вы начнете видеть,
# в каких местах программы следует разместить блоки обработки исключений
# и сколько информации предоставлять пользователям о возникающих ошибках.

# ---------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 10-6. Сложение: при вводе числовых данных часто встречается типичная проблема: поль-
# зователь вводит текст вместо чисел. При попытке преобразовать данные в int происходит
# исключение TypeError. Напишите программу, которая запрашивает два числа, складывает
# их и выводит результат. Перехватите исключение TypeError, если какое-либо из входных
# значений не является числом, и выведите удобное сообщение об ошибке. Протестируйте
# свою программу: сначала введите два числа, а потом введите текст вместо одного из чисел.

# try:
#     a = input("Введите первое число: ")
#     a = int(a)
#     b = input("Введите второе число: ")
#     b = int(b)
# except ValueError:
#     print("Введите число, а не букву или знак!\n")
# else:
#     sum = a + b
#     print("сумма чисел " + str(a) + " + " + str(b) + " равняется " + " = " + str(sum) + "\n")

# ---------------------------------------------------------------------------------------------------------------------

# 10-7. Калькулятор: заключите код из упражнения 10-6 в цикл while, чтобы пользователь
# мог продолжать вводить числа, даже если он допустил ошибку и ввел текст вместо числа.


# while True:
#     print("Введите q для выхода из цикла")
#     try:
#         a = input("Введите первое число: ")
#         if a == "q":
#             break
#
#         a = int(a)
#
#         b = input("Введите второе число: ")
#         if b == "q":
#             break
#
#         b = int(b)
#
#
#     except ValueError:
#         print("Введите число, а не букву или знак!\n")
#     else:
#         sum = a + b
#         print("сумма чисел " + str(a) + " + " + str(b) + " равняется " + " = " + str(sum) + "\n")

# стр 203

# --------------------------------------------------------------------------------------------------------------------

# 10-8. Кошки и собаки: создайте два файла с именами cats.txt и dogs.txt. Сохраните минимум
# три клички кошек в первом файле и три клички собак во втором. Напишите программу,
# которая пытается прочитать эти файлы и выводит их содержимое на экран. Заключите
# свой код в блок try-except для перехвата исключения FileNotFoundError и вывода понятного
# сообщения об отсутствии файла. Переместите один из файлов в другое место файловой
# системы; убедитесь в том, что код блока except выполняется, как и положено.

with open("pass") as files_object:
    pass