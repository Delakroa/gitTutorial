# Создание и использование класса

# Классы позволяют моделировать практически все что угодно. Начнем с написания
# простого класса Dog, представляющего собаку — не какую-то конкретную, а собаку
# вообще. Что мы знаем о собаках? У них есть кличка и возраст. Также известно, что
# большинство собак умеют садиться и перекатываться по команде. Эти два вида
# информации (кличка и возраст) и два вида поведения (сидеть и перекатываться)
# будут включены в класс Dog, потому что они являются общими для большинства
# собак. Класс сообщает Python, как создать объект, представляющий собаку. По-
# сле того как класс будет написан, мы используем его для создания экземпляров,
# каждый из которых представляет одну конкретную собаку.

# --------------------------------------------------------------------------------------------------------------------

# Создание класса Dog

# В каждом экземпляре, созданном на основе класса Dog, будет храниться кличка
# и возраст; кроме того, в нем будут присутствовать методы sit() и roll_over():

# class Dog():  # 1
#     """Простая модель собаки."""  # 2


# def __init__(self, name, age):  # 3
#     """Инициализирует атрибуты name и age."""

# self.name = name  # 4
# self.age = age


# def site(self):  # 5
#     """Собака садится по команде."""
#     print(self.name.title() + " сейчас сидит.")


# def roll_over(self):
#     """Собака перекатывается по команде."""
#     print(self.name.title() + "сейчас перекатывается!")

# В этом коде есть много мест, заслуживающих вашего внимания, но не беспокойтесь.
# Эта структура неоднократно встретится вам в этой главе, и вы еще успеете к ней
# привыкнуть. В точке  определяется класс с именем Dog. По общепринятым согла-
# шениям имена, начинающиеся с символа верхнего регистра, в Python обозначают
# классы. Круглые скобки в определении класса пусты, потому что класс создается
# с нуля. В точке  приведена строка документации с кратким описанием класса.
#
# Метод __init__()
#
# Функция, являющаяся частью класса, называется методом. Все, что вы узнали
# ранее о функциях, также относится и к методам; единственное практическое раз-
# личие — способ вызова методов. Метод __init__() в точке  — специальный метод,
# который автоматически выполняется при создании каждого нового экземпляра
# на базе класса Dog. Имя метода начинается и заканчивается двумя символами
# подчеркивания; эта схема предотвращает конфликты имен стандартных методов
# Python и методов ваших классов.
# 162 Глава 9 • Классы
# Метод __init__() определяется с тремя параметрами: self, name и age. Пара-
# метр self обязателен в определении метода; он должен предшествовать всем
# остальным параметрам. Он должен быть включен в определение для того, чтобы
# при будущем
# вызове метода __init__() (для создания экземпляра Dog) автомати-
# чески передавался аргумент self. При каждом вызове метода, связанного с клас-
# сом, автоматически передается self — ссылка на экземпляр; она предоставляет
# конкретному экземпляру доступ к атрибутам и методам класса. Когда вы создаете
# экземпляр Dog, Python вызывает метод __init__() из класса Dog. Мы передаем
# Dog() кличку и возраст в аргументах; значение self передается автоматически, так
# что его передавать не нужно. Каждый раз, когда вы захотите создать экземпляр
# на основе класса Dog, необходимо предоставить значения только двух последних
# аргументов name и age.
# Каждая из двух переменных, определяемых в точке , имеет префикс self. Лю-
# бая переменная с префиксом self доступна для каждого метода в классе, и вы
# также сможете обращаться к этим переменным в каждом экземпляре, созданном
# на основе класса. Конструкция self.name = name берет значение, хранящееся
# в параметре name, и сохраняет его в переменной name, которая затем связыва-
# ется с создаваемым экземпляром. Процесс также повторяется с self.age = age.
# Переменные, к которым вы обращаетесь через экземпляры, тоже называются
# атрибутами.
# В классе Dog также определяются два метода: sit() и roll_over() . Так как
# этим методам не нужна дополнительная информация (кличка или возраст), они
# определяются с единственным параметром self. Экземпляры, которые будут
# созданы позднее, смогут вызывать эти методы. Пока методы sit() и roll_over()
# ограничиваются простым выводом сообщения о том, что собака садится или
# перекатывается. Тем не менее концепцию легко расширить для практического
# применения: если бы этот класс был частью компьютерной игры, то эти методы
# вполне могли бы содержать код для создания анимации садящейся или пере-
# катывающейся собаки. А если бы класс был написан для управления роботом,
# то методы могли бы управлять механизмами, заставляющими робота-собаку
# выполнить соответствующую команду.

# ---------------------------------------------------------------------------------------------------------------------

# Создание экземпляра класса

# Считайте, что класс — это своего рода инструкция по созданию экземпляров. Со-
# ответственно, класс Dog — инструкция по созданию экземпляров, представляющих
# конкретных собак.
# Создадим экземпляр, представляющий конкретную собаку:

# my_dog = Dog('вилли', 6)
# print("Имя моей собаки " + my_dog.name.title() + ".")
# print("Моей собаке " + str(my_dog.age) + "лет.")


# Использованный в данном случае класс Dog был написан в предыдущем при-
# мере. В точке  мы приказываем Python создать экземпляр собаки с кличкой
# 'willie' и возрастом 6. В процессе обработки этой строки Python вызывает ме-
# тод __init__() класса Dog с аргументами 'willie' и 6. Метод __init__() создает
# экземпляр,
# представляющий конкретную собаку, и присваивает его атрибутам name
# и age переданные значения. Метод __init__() не содержит явной команды return,
# но Python автоматически возвращает экземпляр, представляющий собаку. Этот
# экземпляр сохраняется в переменной my_dog. Здесь нелишне вспомнить соглаше-
# ния по записи имен: обычно считается, что имя, начинающееся с символа верхнего
# регистра (например, Dog), обозначает класс, а имя, записанное в нижнем регистре
# (например, my_dog), обозначает отдельный экземпляр, созданный на базе класса.
# ---------------------------------------------------------------------------------------------------------------------

# Обращение к атрибутам

# Для обращения к атрибутам экземпляра используется «точечная» запись. В стро-
# ке  мы обращаемся к значению атрибута name экземпляра my_dog:
# my_dog.name
# Точечная запись часто используется в Python. Этот синтаксис показывает, как
# Python ищет значения атрибутов. В данном случае Python обращается к экзем-
# пляру my_dog и ищет атрибут name, связанный с экземпляром my_dog. Это тот же
# атрибут, который обозначался self.name в классе Dog. В точке  тот же прием ис-
# пользуется для работы с атрибутом age. В первой команде print вызов my_dog.name.
# title() записывает 'willie' (значение атрибута name экземпляра my_dog) с символа
# верхнего регистра. Во второй команде print вызов str(my_dog.age) преобразует 6,
# значение атрибута age экземпляра my_dog, в строку.
# Пример выводит сводку известных фактов о my_dog:

# ---------------------------------------------------------------------------------------------------------------------

# Вызов методов

# После создания экземпляра на основе класса Dog можно применять точечную за-
# пись для вызова любых методов, определенных в Dog:

# class Dog():
#     ...


# my_dog = Dog('вилли', 6)
# my_dog.sit()
# my_dog.roll_over()


# Чтобы вызвать метод, укажите экземпляр (в данном случае my_dog) и вызываемый
# метод, разделив их точкой. В ходе обработки my_dog.sit() Python ищет метод sit()
# в классе Dog и выполняет его код. Строка my_dog.roll_over() интерпретируется
# аналогичным образом.
# Теперь экземпляр послушно выполняет полученные команды:
# Willie is now sitting.
# Willie rolled over!
# Это очень полезный синтаксис. Если атрибутам и методам были присвоены содер-
# жательные имена (например, name, age, sit() и roll_over()), разработчик сможет
# легко понять, что делает блок кода, — даже если он видит этот блок впервые.

# ------------------------------------------------------------------------------------------------------------------

# Создание нескольких экземпляров

# На основе класса можно создать столько экземпляров, сколько вам потребуется.
# Создадим второй экземпляр Dog с именем your_dog:

# class Dog():
#     ...


# my_dog = Dog('willie', 6)
# your_dog = Dog('lucy', 3)
# print("My dog's name is " + my_dog.name.title() + ".")
# print("My dog is " + str(my_dog.age) + " years old.")
# my_dog.sit()
# print("\nYour dog's name is " + your_dog.name.title() + ".")
# print("Your dog is " + str(your_dog.age) + " years old.")
# your_dog.sit()


# В этом примере создаются два экземпляра с именами Willie и Lucy. Каждый экзем-
# пляр обладает своим набором атрибутов и способен выполнять действия из общего
# набора:

# Даже если второй собаке будут назначены те же имя и возраст, Python все
# равно создаст отдельный экземпляр класса Dog. Вы можете создать сколько
# угодно экземпляров
# одного класса при условии, что эти экземпляры хранятся
# в переменных с разными именами или занимают разные позиции в списке или
# словаре:

# ---------------------------------------------------------------------------------------------------------------------
# УПРАЖНЕНИЯ

# 9-1. Ресторан: создайте класс с именем Restaurant. Метод __init__() класса Restaurant дол-
# жен содержать два атрибута: restaurant_name и cuisine_type. Создайте метод describe_
# restaurant(), который выводит два атрибута, и метод open_restaurant(), который выводит
# сообщение о том, что ресторан открыт.
# Создайте на основе своего класса экземпляр с именем restaurant. Выведите два атрибута по
# отдельности, затем вызовите оба метода.

# class Restaurant():
#     """Создание ресторана."""

# def __init__(self, restaurant_name, cuisine_type):
#     """Инициализация атрибута restaurant_name, cuisine_type """
#     self.restaurant_name = restaurant_name
#     self.cuisine_type = cuisine_type

# def describe_restaurant(self):
#     """Описание ресторана."""
#     print(self.cuisine_type.title() + " типичная кухня.")

# def open_restaurant(self):
#     """Открытие ресторана"""
#     print(self.restaurant_name.title() + " ресторан открылся!")


# restaurant = Restaurant("дикая роза", "русская народная кухня")
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")
# print(restaurant.restaurant_name.title() + " : " + restaurant.cuisine_type.title() + ".")

# --------------------------------------------------------------------------------------------------------------------

# 9-2. Три ресторана: начните с класса из упражнения 9-1. Создайте три разных экземпляра,
# вызовите для каждого экземпляра метод describe_restaurant().

# class Restaurant():
#     """Создание ресторана."""

# def __init__(self, restaurant_name, cuisine_type, stile, attendance):
#     """Инициализация атрибута restaurant_name, cuisine_type """
#     self.restaurant_name = restaurant_name
#     self.cuisine_type = cuisine_type
#     self.stile = stile
#     self.attendance = attendance

# def describe_restaurant(self):
#     """Описание ресторана."""
#     print(self.cuisine_type.title() + " " + self.stile + ", кол - во людей за день: " + str(self.attendance))

# def open_restaurant(self):
#     """Открытие ресторана"""
#     print("Добро пожаловать! Ресторан " + self.restaurant_name.title() + " открылся!")


# restaurant = Restaurant("дикая роза", "типичная кухня", "итальянской стилистики", 3000)
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")

# restaurant.describe_restaurant()
# restaurant.open_restaurant()

# ---------------------------------------------------------------------------------------------------------------------

# 9-3. Пользователи: создайте класс с именем User. Создайте два атрибута first_name и last_
# name, а затем еще несколько атрибутов, которые обычно хранятся в профиле пользова-
# теля. Напишите метод describe_user(), который выводит сводку с информацией о пользо-
# вателе. Создайте еще один метод greet_user() для вывода персонального приветствия для
# пользователя.
# Создайте несколько экземпляров, представляющих разных пользователей. Вызовите оба
# метода для каждого пользователя.

# class User():
#     """sozdanie polzovatelia"""

# def __init__(self, first_name, last_name, age, sex):
#     """Инициализируем пользователя."""
#     self.first_name = first_name
#     self.last_name = last_name
#     self.age = age
#     self.sex = sex

# def describe_user(self):
#     """Описание пользователя"""
#     summary_of_informations = ("Имя: " + self.first_name + "," + " Фамилия: " + self.last_name + "," + " Возраст: " +
#                                str(self.age) + "," + " Пол: " + self.sex).title()
#     print(summary_of_informations)

# def greet_user(self):
#     """Приветствие пользователя"""
#     print("Приветствую вас! " + self.first_name.title() + " " + self.last_name.title())


# print("\t****Описание пользователя:****")
# user_1 = User("vladimir", "rahmano", 32, "man")
# user_2 = User("dmitry", "halikov", 34, "man")
# user_3 = User("oleg", "evseev", 37, "man")

# user_1.describe_user()
# user_2.describe_user()
# user_3.describe_user()
# print("----------------------------------------------------------")
# print("\t****Приветствие пользователя:****")
# user_1.greet_user()
# user_2.greet_user()
# user_3.greet_user()

# ---------------------------------------------------------------------------------------------------------------------

# Работа с классами и экземплярами

# Классы могут использоваться для моделирования многих реальных ситуаций. По-
# сле того как класс будет написан, разработчик проводит бульшую часть времени
# за работой с экземплярами, созданными на основе этого класса. Одной из первых
# задач станет изменение атрибутов, связанных с конкретным экземпляром. Атрибу-
# ты экземпляра можно изменять напрямую или же написать методы, изменяющие
# атрибуты по особым правилам.

# --------------------------------------------------------------------------------------------------------------------

# Класс Car

# Напишем класс, представляющий автомобиль. Этот класс будет содержать инфор-
# мацию о типе машины, а также метод для вывода краткого описания:

# class Car():
#     """Простая модель автомобиля"""

# def __init__(self, make, model, year):  # 1
#     """Инициализация атрибута и описание автомобиля."""
#     self.make = make
#     self.model = model
#     self.year = year

# def get_descriptive_name(self):  # 2
#     """Возвращает аккуратно отформатированное описание."""
#     long_name = (self.make + " " + self.model + " " + str(self.year))
#     return long_name.title()


# my_new_car = Car('audi', 'a4', 2016)  # 3
# print(my_new_car.get_descriptive_name())


# В точке  в классе Car определяется метод __init__(); его список параметров на-
# чинается с self, как и в классе Dog. За ним следуют еще три параметра: make, model
# и year. Метод __init__() получает эти параметры и сохраняет их в атрибутах, ко-
# торые будут связаны с экземплярами, созданными на основе класса. При создании
# нового экземпляра Car необходимо указать фирму-производителя, модель и год
# выпуска для данного экземпляра.
# В точке  определяется метод get_descriptive_name(), который объединяет год
# выпуска, фирму-производителя и модель в одну строку с описанием. Это избавит
# вас от необходимости выводить значение каждого атрибута по отдельности. Для
# работы со значениями атрибутов в этом методе используется синтаксис self.make,
# self.model и self.year.
# В точке  создается экземпляр класса Car, который сохраняется в переменной
# my_new_car. Затем вызов метода get_descriptive_name() показывает, с какой ма-
# шиной работает программа:
# 2016 Audi A4
# Чтобы класс был более интересным, добавим атрибут, изменяющийся со време-
# нем, — в нем будет храниться пробег машины в милях.

# --------------------------------------------------------------------------------------------------------------------

# Назначение атрибуту значения по умолчанию

# Каждый атрибут класса должен иметь исходное значение, даже если оно равно
# 0 или пустой строке. В некоторых случаях (например, при задании значений по
# умолчанию) это исходное значение есть смысл задавать в теле метода __init__();
# в таком случае передавать параметр для этого атрибута при создании объекта
# не обязательно.
# Добавим атрибут с именем odometer_reading, исходное значение которого всегда
# равно 0. Также в класс будет включен метод read_odometer() для чтения текущих
# показаний одометра:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 0   #1
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make + " " + self.model + " " + str(self.year))
#         return long_name.title()
#
#     def read_odometer(self):   #2
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " миль. ")


# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
# my_new_car.read_odometer()


# Когда Python вызывает метод __init__() для создания нового экземпляра, этот
# метод сохраняет фирму-производителя, модель и год выпуска в атрибутах, как
# и в предыдущем случае. Затем Python создает новый атрибут с именем odometer_
# reading и присваивает ему исходное значение 0 . Также в класс добавляется
# новый метод read_odometer() , который упрощает чтение пробега машины
# в милях.

# Сразу же после создания машины ее пробег равен 0:

# 2016 Audi A4
# This car has 0 miles on it.

# Впрочем, у продаваемых машин одометр редко показывает ровно 0, поэтому нам
# понадобится способ изменения значения этого атрибута.

# --------------------------------------------------------------------------------------------------------------------

# Изменение значений атрибутов

# Значение атрибута можно изменить одним из трех способов: изменить его прямо
# в экземпляре, задать значение при помощи метода или изменить его с приращением
# (то есть прибавлением определенной величины) при помощи метода. Рассмотрим
# все эти способы.

# --------------------------------------------------------------------------------------------------------------------

# Прямое изменение значения атрибута

# Чтобы изменить значение атрибута, проще всего обратиться к нему прямо через эк-
# земпляр. В следующем примере на одометре напрямую выставляется значение 23:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 0
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")


# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
# my_new_car.odometer_read = 23   #1
# my_new_car.read_odometer()

# В точке  точечная запись используется для обращения к атрибуту odometer_
# reading экземпляра и прямого присваивания его значения. Эта строка приказывает
# Python взять экземпляр my_new_car, найти связанный с ним атрибут odometer_
# reading и задать значение атрибута равным 23:
# Иногда подобные прямые обращения к атрибутам допустимы, но чаще разработчик
# пишет вспомогательный метод, который изменяет значение за него.

# --------------------------------------------------------------------------------------------------------------------

# Изменение значения атрибута с использованием метода

# В класс можно включить методы, которые изменяют некоторые атрибуты за вас.
# Вместо того чтобы изменять атрибут напрямую, вы передаете новое значение ме-
# тоду, который берет обновление атрибута на себя.
# В следующем примере в класс включается метод update_odometer() для изменения


# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):        # 1
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)    # 2
# my_new_car.read_odometer()


# Класс Car почти не изменился, в нем только добавился метод update_odometer().
# Этот метод получает пробег в милях и сохраняет его в self.odometer_reading.
# В точке  мы вызываем метод update_odometer() и передаем ему значение 23
# в аргументе (соответствующем параметру mileage в определении метода). Метод
# устанавливает на одометре значение 23, а метод read_odometer() выводит текущие
# показания:

# Метод update_odometer() можно расширить так, чтобы при каждом изменении
# показаний одометра выполнялась некоторая дополнительная работа. Добавим
# проверку, которая гарантирует, что никто не будет пытаться сбрасывать показания
# одометра:

# Теперь update_odometer() проверяет новое значение перед изменением атрибута.
# Если новое значение mileage больше или равно текущего, self.odometer_reading,
# показания одометра можно обновить новым значением . Если же новое значение
# меньше текущего, вы получите предупреждение о недопустимости обратной под-
# крутки .

# --------------------------------------------------------------------------------------------------------------------

# Изменение значения атрибута с приращением

# Иногда значение атрибута требуется изменить с заданным приращением (вме-
# сто того чтобы присваивать атрибуту произвольное новое значение). Допустим,
# Работа с классами и экземплярами 169
# вы купили подержанную машину и проехали на ней 100 миль. Следующий метод
# получает величину приращения и прибавляет ее к текущим показаниям одометра:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):  # 1
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)  # 2
# my_new_car.read_odometer()
# print("\t********************")          # нужн понять и исправить работу
# my_used_car = Car('subaru', 'outback', 2013)  # 2
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)  # 3
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)  # 4
# my_used_car.read_odometer()


# Новый метод increment_odometer() в точке  получает расстояние в милях
# и прибавляет его к self.odometer_reading. В точке  создается экземпляр
# my_used_car. Мы инициализируем показания его одометра значением 23 500;
# для этого вызывается метод update_odometer(), которому передается значение
# 23500 . В точке  вызывается метод increment_odometer(), которому передает-
# ся значение 100, чтобы увеличить показания одометра на 100 миль, пройденные
# с момента покупки:

# ---------------------------------------------------------------------------------------------------------------------

# 9-4. Посетители: начните с программы из упражнения 9-1 (с. 165). Добавьте атрибут
# number_served со значением по умолчанию 0; он представляет количество обслуженных
# посетителей. Создайте экземпляр с именем restaurant. Выведите значение number_served,
# потом измените и выведите снова.
# Добавьте метод с именем set_number_served(), позволяющий задать количество обслужен-
# ных посетителей. Вызовите метод с новым числом, снова выведите значение.
# 170 Глава 9 • Классы
# Добавьте метод с именем increment_number_served(), который увеличивает количество
# обслуженных посетителей на заданную величину. Вызовите этот метод с любым числом,
# которое могло бы представлять количество обслуженных клиентов — скажем, за один день.


# class Restaurant():
#     """Создание ресторана."""
#
#     def __init__(self, restaurant_name, cuisine_type, ):
#         """Инициализация атрибута restaurant_name, cuisine_type """
#         self.restaurant_name = restaurant_name
#         self.cuisine_type = cuisine_type
#         self.number_served = 100
#
#     def describe_restaurant(self):
#         """Описание ресторана."""
#         print(self.cuisine_type.title() + " типичная кухня.")
#
#     def open_restaurant(self):
#         """Открытие ресторана"""
#         print(self.restaurant_name.title() + " ресторан открылся!")
#
#     def set_number_served(self, quantity):
#         """Вывод количества посетителей"""
#         self.number_served = quantity
#
#     def increment_number_served(self, quantit):
#         """Увеличение количества посетителей на заданную величину."""
#         self.number_served += quantit
#
#
#
# restaurant = Restaurant("дикая роза", "русская народная кухня")
# print("Название ресторана: " + restaurant.restaurant_name.title() + ".")
# print("Очень вкусная " + restaurant.cuisine_type.title() + ".")
# print(restaurant.restaurant_name.title() + " : " + restaurant.cuisine_type.title() + ".")
#
# restaurant.set_number_served(1000)
# restaurant.increment_number_served(2000)
# print("Количество обслуженных посетителей: " + str(restaurant.number_served))

# ---------------------------------------------------------------------------------------------------------------------

# 9-5 Попытки входа: добавьте атрибут login_attempts в класс User из упражнения 9-3
# (с 165) Напишите метод increment_login_attempts(), увеличивающий значение login_
# attempts на 1 Напишите другой метод с именем reset_login_attempts(), обнуляющий значение login_attempts
# Создайте экземпляр класса User и вызовите increment_login_attempts() несколько раз Выведите значение login_attempts,
# чтобы убедиться в том, что значение было изменено правильно, а затем вызовите reset_login_attempts()
# Снова выведите login_attempts и убедитесь в том, что значение обнулилось

# class User():
#     """sozdanie polzovatelia"""
#
#     def __init__(self, first_name, last_name, age, sex):
#         """Инициализируем пользователя."""
#         self.first_name = first_name
#         self.last_name = last_name
#         self.age = age
#         self.sex = sex
#         self.login_attempts = 0
#
#     def describe_user(self):
#         """Сводка с информацией о пользрвателе."""
#         summary_of_informations = ("Имя: " + self.first_name + "," + " Фамилия: " + self.last_name
#                                    + "," + " Возраст: " + str(self.age) + "," + " Пол: " + self.sex).title()
#         print(summary_of_informations)
#
#     def greet_user(self):
#         """Приветствие пользователя"""
#         print("Приветствую вас! " + self.first_name.title() + " " + self.last_name.title())
#
#     def read_user(self):
#         """Выводит пользователей"""
#         print("Количество пользователей: " + str(self.login_attempts))
#
#     def increment_login_attempts(self, count):
#         """Подсчёт пользователей."""
#         self.login_attempts += count
#         print("Количество пользователй: " + str(self.login_attempts))
#
#     def reset_login_attempts(self):
#         pass
#
#
# print("\t****Описание пользователя:****")
# user_1 = User("vladimir", "rahmano", 32, "man")
# user_2 = User("dmitry", "halikov", 34, "man")
# user_3 = User("oleg", "evseev", 37, "man")
#
# user_1.describe_user()
# user_2.describe_user()
# user_3.describe_user()
#
# print("----------------------------------------------------------")
# print("\t****Приветствие пользователя:****")
#
# user_1.greet_user()
# user_2.greet_user()
# user_3.greet_user()
#
# print("----------------------------------------------------------")
# user_1.increment_login_attempts = 1
# user_2.increment_login_attempts = 1
# user_3.increment_login_attempts = 1
# all_user = (user_1, user_2, user_3)
# user_1.read_user()
# user_2.read_user()
# user_3.read_user()

# --------------------------------------------------------------------------------------------------------------------

# Наследование

# Работа над новым классом не обязана начинаться с нуля. Если класс, который вы
# пишете, представляет собой специализированную версию ранее написанного класса, вы можете воспользоваться
# наследованием.
# Один класс, наследующий от другого,автоматически получает все атрибуты и методы первого класса. Исходный класс
# называется родителем, а новый класс — потомком. Класс-потомок наследует
# атрибуты и методы родителя, но при этом также может определять собственные
# атрибуты и методы.

# --------------------------------------------------------------------------------------------------------------------

# Метод __init__() класса-потомка

# Первое, что делает Python при создании экземпляра класса-потомка, — присваивает
# значения всем атрибутам класса-родителя. Для этого методу __init__() класса-потомка
# необходима помощь со стороны родителя.
# Например, попробуем построить модель электромобиля. Электромобиль представляет собой
# специализированную разновидность автомобиля, поэтому новый
# класс ElectricCar можно создать на базе класса Car, написанного ранее. Тогда
# нам останется добавить в него код атрибутов и поведения, относящегося только
# к электромобилям.
# Начнем с создания простой версии класса ElectricCar, который делает все, что
# делает класс Car:

# class Car():    # 1
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)
# my_new_car.read_odometer()
# print("\t********************")
# my_used_car = Car('subaru', 'outback', 2013)
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)
# my_used_car.read_odometer()
#
#
# class ElectricCar(Car):
#     """Представляет аспекты машины, специфические для электромобилей."""
#
#     def __init__(self, make, model, year):  # 3
#         """Инициализирует атрибуты класса-родителя."""
#         super().__init__(make, model, year)  # 4
#
#
# my_tesla = ElectricCar('tesla', 'model s', 2016)  # 5
# print("\t********************")
# print(my_tesla.get_descriptive_name())


# В точке  строится экземпляр Car. При создании класса-потомка класс-родитель
# должен быть частью текущего файла, а его определение должно предшествовать
# определению класса-потомка в файле. В точке  определяется класс-потомок
# ElectricCar. В определении потомка имя класса-родителя заключается в круглые
# скобки. Метод __init__() в точке  получает информацию, необходимую для
# создания экземпляра Car.
# Функция super() в строке  — специальная функция, которая помогает Python
# связать потомка с родителем. Эта строка приказывает Python вызвать метод
# __init__() класса, являющегося родителем ElectricCar, в результате чего экземпляр ElectricCar получает все атрибуты
# класса-родителя. Имя super происходит
# из распространенной терминологии: класс-родитель называется суперклассом, а класс-потомок — субклассом.
# Чтобы проверить, правильно ли сработало наследование, попробуем создать
# электромобиль с такой же информацией, которая передается при создании
# обычного экземпляра Car. В точке  мы создаем экземпляр класса ElectricCar
# и сохраняем его в my_tesla. Эта строка вызывает метод __init__(), определенный в ElectricCar, который в свою
# очередь приказывает Python вызвать метод
# __init__(), определенный в классе-родителе Car. При вызове передаются аргументы 'tesla', 'model s' и 2016.
# Кроме __init__() класс еще не содержит никаких атрибутов или методов, специфических для электромобилей. Пока мы
# просто убеждаемся в том, что класс
# электромобиля содержит все поведение, присущее классу автомобиля:
# Экземпляр ElectricCar работает так же, как экземпляр Car; можно переходить
# к определению атрибутов и методов, специфических для электромобилей.

# ---------------------------------------------------------------------------------------------------------------------

# Определение атрибутов и методов класса-потомка

# После создания класса-потомка, наследующего от класса-родителя, можно пере-
# ходить к добавлению новых атрибутов и методов, необходимых для того, чтобы
# потомок отличался от родителя.
# Добавим атрибут, специфический для электромобилей (например, мощность ак-
# кумулятора), и метод для вывода информации об этом атрибуте:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)
# my_new_car.read_odometer()
# print("\t********************")
# my_used_car = Car('subaru', 'outback', 2013)
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)
# my_used_car.read_odometer()
#
#
# class ElectricCar(Car):
#     """Представляет аспекты машины, специфические для электромобилей."""
#
#     def __init__(self, make, model, year):
#         """Инициализирует атрибуты класса-родителя.
#         Затем инициализируем атрибуты, специфические для электромобиля."""
#         super().__init__(make, model, year)
#         self.battery_size = 70     # 1
#
#     def describe_battery(self):    # 2
#         """Выводит информацию о мощности аккумулятора."""
#         print("У этой машины есть " + "аккумулятор мощностью: " + str(self.battery_size) + "Кв/ч.")
#
#
# my_tesla = ElectricCar('tesla', 'model s', 2016)  # 5
# print("\t********************")
# print(my_tesla.get_descriptive_name())
# my_tesla.describe_battery()


# В точке  добавляется новый атрибут self.battery_size, которому присваивается
# исходное значение — скажем, 70. Этот атрибут будет присутствовать во всех экзем-
# плярах, созданных на основе класса ElectricCar (но не во всяком экземпляре Car).
# Также добавляется метод с именем describe_battery(), который выводит инфор-
# мацию об аккумуляторе в точке . При вызове этого метода выводится описание,
# которое явно относится только к электромобилям:
# 2016 Tesla Model S
# This car has a 70-kWh battery.
# Возможности специализации класса ElectricCar беспредельны. Вы можете до-
# бавить сколько угодно атрибутов и методов, чтобы моделировать электромобиль
# с любой нужной точностью. Атрибуты или методы, которые могут принадлежать
# любой машине (а не только электромобилю), должны добавляться в класс Car вме-
# сто ElectricCar. Тогда эта информация будет доступна всем пользователям класса
# Car, а класс ElectricCar будет содержать только код информации и поведения,
# специфических для электромобилей.

# --------------------------------------------------------------------------------------------------------------------

# Переопределение методов класса-родителя

# Любой метод родительского класса, который в моделируемой ситуации делает
# не то, что нужно, можно переопределить. Для этого в классе-потомке определяется
# метод с тем же именем, что и у метода класса-родителя. Python игнорирует метод
# родителя и обращает внимание только на метод, определенный в потомке.
# Допустим, в классе Car имеется метод fill_gas_tank(). Для электромобилей за-
# правка бензином бессмысленна, поэтому этот метод логично переопределить. На-
# пример, это можно сделать так:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#     def fill_gas_tank(self):
#         """Обьём бензобака."""
#         print("Обьём бензобака:" + " 120 литров")
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)
# my_new_car.read_odometer()
# my_new_car.fill_gas_tank()
# print("\t********************")
# my_used_car = Car('subaru', 'outback', 2013)
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)
# my_used_car.read_odometer()
# my_used_car.fill_gas_tank()
#
#
# class ElectricCar(Car):
#     """Представляет аспекты машины, специфические для электромобилей."""
#
#     def __init__(self, make, model, year):
#         """Инициализирует атрибуты класса-родителя.
#         Затем инициализируем атрибуты, специфические для электромобиля."""
#         super().__init__(make, model, year)
#         self.battery_size = 70
#
#     def describe_battery(self):
#         """Выводит информацию о мощности аккумулятора."""
#         print("У этой машины есть " + "аккумулятор мощностью: " + str(self.battery_size) + "Кв/ч.")
#
#     def fill_gas_tank(self):
#         """У электромобиля нет бензобака."""
#         print("Этой машине не нужен бензобак!")
#
#
# my_tesla = ElectricCar('tesla', 'model s', 2016)  # 5
# print("\t********************")
# print(my_tesla.get_descriptive_name())
# my_tesla.describe_battery()
# my_tesla.fill_gas_tank()


# И если кто-то попытается вызвать метод fill_gas_tank() для электромобиля,
# Python игнорирует метод fill_gas_tank() класса Car и выполнит вместо него этот
# код. С применением наследования потомок сохраняет те аспекты родителя, которые
# вам нужны, и переопределяет все ненужное.

# ---------------------------------------------------------------------------------------------------------------------

# Экземпляры как атрибуты

# При моделировании явлений реального мира в программах классы нередко до-
# полняются все большим количеством подробностей. Списки атрибутов и мето-
# дов растут, и через какое-то время файлы становятся длинными и громоздкими.
# В такой ситуации часть одного класса нередко можно записать в виде отдельного
# класса. Большой код разбивается на меньшие классы, которые работают во взаи-
# модействии друг с другом.
# Например, при дальнейшей доработке класса ElectricCar может оказаться, что
# в нем появилось слишком много атрибутов и методов, относящихся к аккумулято-
# ру. В таком случае можно остановиться и переместить все эти атрибуты и методы
# в отдельный класс с именем Battery. Затем экземпляр Battery становится атрибу-
# том класса ElectricCar:


# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#     def fill_gas_tank(self):
#         """Обьём бензобака."""
#         print("Обьём бензобака:" + " 120 литров")
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)
# my_new_car.read_odometer()
# my_new_car.fill_gas_tank()
# print("\t********************")
# my_used_car = Car('subaru', 'outback', 2013)
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)
# my_used_car.read_odometer()
# my_used_car.fill_gas_tank()
#
#
# class Battery():  # 1
#     """Простая модель аккумулятора электромобиля."""
#
#     def __init__(self, battery_size=70):  # 2
#         """Инициализирует атрибуты аккумулятора"""
#         self.battery_size = battery_size
#
#     def describe_battery(self):  # 3
#         """Выводит информацию о мощности аккумулятора."""
#         print("У этой машины есть " + "аккумулятор мощностью: " + str(self.battery_size) + "Кв/ч.")
#
#
# class ElectricCar(Car):
#     """Представляет аспекты машины, специфические для электромобилей."""
#
#     def __init__(self, make, model, year):
#         """Инициализирует атрибуты класса-родителя.
#         Затем инициализируем атрибуты, специфические для электромобиля."""
#         super().__init__(make, model, year)
#         self.battery = Battery()  # 4
#
#     def fill_gas_tank(self):
#         """У электромобиля нет бензобака."""
#         print("Этой машине не нужен бензобак!")
#
#
# my_tesla = ElectricCar('tesla', 'model s', 2016)
# print("\t********************")
# print(my_tesla.get_descriptive_name())
# my_tesla.battery.describe_battery()
# my_tesla.fill_gas_tank()


# В точке  определяется новый класс с именем Battery, который не наследует
# ни от одного из других классов. Метод __init__() в точке  получает один пара-
# метр battery_size, кроме self. Если значение не предоставлено, этот необязатель-
# ный параметр задает battery_size значение 70. Метод describe_battery() также
# перемещен в этот класс .
# Затем в класс ElectricCar добавляется атрибут с именем self.battery . Эта стро-
# ка приказывает Python создать новый экземпляр Battery (со значением battery_
# size по умолчанию, равным 70, потому что значение не задано) и сохранить его
# в атрибуте self.battery. Это будет происходить при каждом вызове __init__();
# теперь любой экземпляр ElectricCar будет иметь автоматически создаваемый
# экземпляр Battery.
# Программа создает экземпляр электромобиля и сохраняет его в переменной my_
# tesla. Когда потребуется вывести описание аккумулятора, необходимо обратиться
# к атрибуту battery:
# my_tesla.battery.describe_battery()
# Эта строка приказывает Python обратиться к экземпляру my_tesla, найти его
# атрибут battery и вызвать метод describe_battery(), связанный с экземпляром
# Battery из атрибута.
# Результат выглядит так же, как и в предыдущей версии:

# --------------------------------------------------------------------------------------------------------------------

# Казалось бы, новый вариант требует большой дополнительной работы, но теперь
# аккумулятор можно моделировать с любой степенью детализации без загромож-
# дения класса ElectricCar. Добавим в Battery еще один метод, который выводит
# запас хода на основании мощности аккумулятора:

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#     def fill_gas_tank(self):
#         """Обьём бензобака."""
#         print("Обьём бензобака:" + " 120 литров")
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)
# my_new_car.read_odometer()
# my_new_car.fill_gas_tank()
# print("\t********************")
# my_used_car = Car('subaru', 'outback', 2013)
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)
# my_used_car.read_odometer()
# my_used_car.fill_gas_tank()
#
#
# class Battery():
#     """Простая модель аккумулятора электромобиля."""
#
#     def __init__(self, battery_size=85):
#         """Инициализирует атрибуты аккумулятора"""
#         self.battery_size = battery_size
#
#     def describe_battery(self):
#         """Выводит информацию о мощности аккумулятора."""
#         print("У этой машины есть " + "аккумулятор мощностью: " + str(self.battery_size) + "Кв/ч.")
#
#     def get_range(self):    # 1
#         """Выводит приблизительный запас хода для аккумулятора."""
#         if self.battery_size == 70:
#             range = 240
#         elif self.battery_size == 85:
#             range = 270
#
#         message = ("Эта машина может ехать примерно " + str(range))
#         message += (" миль при полной зарядке.")
#         print(message)
#
# class ElectricCar(Car):
#     """Представляет аспекты машины, специфические для электромобилей."""
#
#     def __init__(self, make, model, year):
#         """Инициализирует атрибуты класса-родителя.
#         Затем инициализируем атрибуты, специфические для электромобиля."""
#         super().__init__(make, model, year)
#         self.battery = Battery()  # 4
#
#     def fill_gas_tank(self):
#         """У электромобиля нет бензобака."""
#         print("Этой машине не нужен бензобак!")
#
#
# my_tesla = ElectricCar('tesla', 'model s', 2016)
# print("\t********************")
# print(my_tesla.get_descriptive_name())
# my_tesla.battery.describe_battery()
# my_tesla.fill_gas_tank()
# my_tesla.battery.get_range()   # 2

# Новый метод get_range() в точке  проводит простой анализ. Если мощность рав-
# на 70, то get_range() устанавливает запас хода 240 миль, а при мощности 85 kWh
# запас хода равен 270 милям. Затем программа выводит это значение. Когда вы
# захотите использовать этот метод, его придется вызывать через атрибут battery
# в точке .
# Результат сообщает запас хода машины в зависимости от мощности аккумулятора:

# ---------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ

# 9-6. Киоск с мороженым: киоск с мороженым — особая разновидность ресторана. Напишите
# класс IceCreamStand, наследующий от класса Restaurant из упражнения 9-1 (с.165) или
# упражнения 9-4 (с. 169). Подойдет любая версия класса; просто выберите ту, которая вам
# больше нравится. Добавьте атрибут с именем flavors для хранения списка сортов мороже-
# ного. Напишите метод, который выводит этот список. Создайте экземпляр IceCreamStand
# и вызовите этот метод.


# class Restaurant():
#     """Создание ресторана."""
#
#     def __init__(self, name, cuisine_type):
#         """Инициализация атрибута restaurant_name, cuisine_type """
#         self.name = name.title()
#         self.cuisine_type = cuisine_type
#         self.number_served = 0
#
#     def describe_restaurant(self):
#         """Описание ресторана."""
#         msg = ("Ресторан: " + self.name + " замечательная серверовка " + self.cuisine_type + ".")
#         print("\n" + msg)
#
#     def open_restaurant(self):
#         """Открытие ресторана"""
#         msg = (self.name + " открыто. Добро пожаловать!")
#         print("\n" + msg)
#
#     def set_number_served(self, number_served):
#         """Разрешить пользователю устанавливать количество обслуживаемых клиентов."""
#         self.number_served = number_served
#
#     def increment_number_served(self, additional_served):
#         """Разрешить пользователю увеличивать количество обслуживаемых клиентов."""
#         self.number_served += additional_served
#
#
# restaurant = Restaurant("дикая роза", "типичная кухня")
# restaurant.describe_restaurant()
#
# print("\nКоличества обслуживания: " + str(restaurant.number_served))
# restaurant.number_served = 430
# print("Количества обслуживания: " + str(restaurant.number_served))
#
# restaurant.set_number_served(1250)
# print("Количества обслуживания: " + str(restaurant.number_served))
#
# restaurant.increment_number_served(239)
# print("Количества обслуживания: " + str(restaurant.number_served))
#
# class IceCreamStand(Restaurant):
#     """Описание киоска с мороженным"""
#
#     def __init__(self, restaurant_name, cuisine_type='мороженного'):
#         """Инициализация атрибутов класса родителя, затем инициализация атрибутов
#         специфических для киоска с мороженным"""
#         super().__init__(restaurant_name, cuisine_type)
#         self.flavors = []
#
#     def show_flavors(self):
#         """Показать доступные вкусы."""
#         print("\nУ нас есть следующие вкусы:")
#         for flavor in self.flavors:
#             print("- " + flavor.title())
#
#
# morojenoe = IceCreamStand('Вкусная')
# morojenoe.flavors = ['vanilla', 'chocolate', 'black cherry']
#
# morojenoe.describe_restaurant()
# morojenoe.show_flavors()


#
# ---------------------------------------------------------------------------------------------------------------------
#
# 9-7. Администратор: администратор — особая разновидность пользователя. Напишите
# класс с именем Admin, наследующий от класса User из упражнения 9-3 (с.165) или
# упражнения 9-5 (с. 170). Добавьте атрибут privileges для хранения списка строк вида
# «разрешено добавлять сообщения», «разрешено удалять пользователей», «разрешено
# банить пользователей» и т.д. Напишите метод show_privileges() для вывода набора
# привилегий администратора. Создайте экземпляр Admin и вызовите свой метод.
#
# 9-8. Привилегии: напишите класс Privileges. Класс должен содержать всего один атрибут
# privileges со списком строк из упражнения 9-7. Переместите метод show_privileges() в этот
# класс. Создайте экземпляр Privileges как атрибут класса Admin. Создайте новый экземпляр
# Admin и используйте свой метод для вывода списка привилегий.
#
# class User():
#     """sozdanie polzovatelia"""
#
#     def __init__(self, first_name, last_name, username, email, location):
#         """Инициализируем пользователя."""
#         self.first_name = first_name.title()
#         self.last_name = last_name.title()
#         self.username = username.title()
#         self.email = email
#         self.location = location.title()
#         self.login_attempts = 0
#
#     def describe_user(self):
#         """Описание пользователя"""
#         print(self.first_name + " " + self.last_name)
#         print(" Username: " + self.username)
#         print(" Email: " + self.email)
#         print(" Location: " + self.location)
#
#     def greet_user(self):
#         """Приветствие пользователя"""
#         print("Приветствую вас! " + self.username)
#
#     def increment_login_attempts(self):
#         """Подсчёт рабочих."""
#         self.login_attempts += 1  # подсчитывает рабочих
#
#     def reset_login_attempts(self):
#         """Сброс количества рабочих"""
#         self.login_attempts = 0
#
#
# print("\t****Описание пользователя:****")
#
# user_dmitry = User("dmitry", "khalikov", "delakroa", "kat@list.ru", "russia")
# user_vladimer = User("vladimer", "rahmanov", "programer", "rahmanov@gmail.com", "russia")
# print("----------------------------------------------------------")
# user_dmitry.describe_user()
# user_dmitry.greet_user()
# print("----------------------------------------------------------")
# user_vladimer.describe_user()
# user_vladimer.greet_user()
# print("----------------------------------------------------------")
# print("Сделано 3 попытки входа ...")
# user_dmitry.increment_login_attempts()
# user_dmitry.increment_login_attempts()
# user_vladimer.increment_login_attempts()
# print(" Попытка входа в систему: " + str(user_dmitry.login_attempts))
# print(" Попытка входа в систему: " + str(user_vladimer.login_attempts))
# print("----------------------------------------------------------")
# print("Попытка сброса входа...")
# user_dmitry.reset_login_attempts()
# user_vladimer.reset_login_attempts()
# print(" Попытка входа в систему " + str(user_dmitry.login_attempts))
# print(" Попытка входа в систему " + str(user_vladimer.login_attempts))
#
#
# class Admin(User):
#     """Описание администратора"""
#
#     def __init__(self, first_name, last_name, username, email, location):
#         """Инициализирует атрибуты класса-родителя.
#         Затем инициализируем атрибуты, специфические для электромобиля."""
#         super().__init__(first_name, last_name, username, email, location)
#         self.privileges = Privileges()  # Инициализировать пустой набор привелегий
#
#
# class Privileges():
#     """Клас для хранения прав администратора"""
#
#     def __init__(self, privileges=[]):
#         self.privileges = privileges
#
#     def show_privileges(self):
#         print("\nPrivileges:")
#         if self.privileges:
#             for privilege in self.privileges:
#                 print("- " + privilege)
#         else:
#             print("- У этого пользователя нет привилегий.")
#
#
# print("\n----Admin Dmitry----\n")
# dmitry = Admin("dmitry", "khalikov", "delakroa", "kat@list.ru", "russia")
# # print("---------------------------------------------------")
# dmitry.describe_user()
# dmitry.privileges.show_privileges()
#
# print("\nДобавление привелегий...")
# user_admin_privileges = [
#     'сброс пароля',
#     'модерирровать сообщения',
#     'управлять аккаунтами',
# ]
#
# dmitry.privileges.privileges = user_admin_privileges
# dmitry.privileges.show_privileges()

# ---------------------------------------------------------------------------------------------------------------------

# 9-9. Обновление аккумулятора: используйте окончательную версию программы
# electric_car.py из этого раздела. Добавьте в класс Battery метод с именем upgrade_battery().
# Этот метод должен проверять размер аккумулятора и устанавливать мощность равной 85,
# если она имеет другое значение. Создайте экземпляр электромобиля с аккумулятором
# по умолчанию, вызовите get_range(), а затем вызовите get_range() во второй раз после
# вызова upgrade_battery(). Убедитесь в том, что запас хода увеличился.

# class Car():
#     """Простая модель автомобиля"""
#
#     def __init__(self, make, model, year):
#         """Инициализация атрибута и описание автомобиля."""
#         self.make = make
#         self.model = model
#         self.year = year
#         self.odometer_read = 100
#
#     def get_descriptive_name(self):
#         """Возвращает аккуратно отформатированное описание."""
#         long_name = (self.make.title() + " " + self.model.title() + " " + str(self.year) + " года")
#         return long_name
#
#     def read_odometer(self):
#         """Выводит пробег машины в милях"""
#         print("На этой машине пробег " + str(self.odometer_read) + " мили. ")
#
#     def update_odometer(self, mileage):
#         """Установить заданное значение на одометре.
#         При попытке обратной прокрутки изменени отклоняются."""
#         if mileage >= self.odometer_read:
#             self.odometer_read = mileage
#         else:
#             print("Вы не можете скрутить одометр")
#
#     def increment_odometer(self, miles):
#         """Увеличивает показания одометра с заданным приращением."""
#         self.odometer_read += miles
#
#     def fill_gas_tank(self):
#         """Обьём бензобака."""
#         print("Обьём бензобака:" + " 120 литров")
#
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.update_odometer(50)
# my_new_car.read_odometer()
# my_new_car.fill_gas_tank()
# print("\t********************")
# my_used_car = Car('subaru', 'outback', 2013)
# print(my_used_car.get_descriptive_name())
#
# my_used_car.update_odometer(23500)
# my_used_car.read_odometer()
#
# my_used_car.increment_odometer(100)
# my_used_car.read_odometer()
# my_used_car.fill_gas_tank()
#
#
# class Battery():
#     """Простая модель аккумулятора электромобиля."""
#
#     def __init__(self, battery_size=70):
#         """Инициализирует атрибуты аккумулятора"""
#         self.battery_size = battery_size
#
#     def describe_battery(self):
#         """Выводит информацию о мощности аккумулятора."""
#         print("У этой машины есть " + "аккумулятор мощностью: " + str(self.battery_size) + "Кв/ч.")
#
#     def get_range(self):
#         """Выводит приблизительный запас хода для аккумулятора."""
#         if self.battery_size == 70:
#             range = 240
#         elif self.battery_size == 85:
#             range = 270
#
#         message = ("Эта машина может ехать примерно " + str(range))
#         message += (" миль при полной зарядке.")
#         print(message)
#
#     def upgrade_battery(self):
#         """Улучшение батареи."""
#         if self.battery_size == 70:
#             self.battery_size = 85
#             print("Аккумулятор увеличен до 85 кВтч.")
#         else:
#             print("Аккумулятор уже обновлен.")
#
#
#
#
# class ElectricCar(Car):
#     """Представляет аспекты машины, специфические для электромобилей."""
#
#     def __init__(self, make, model, year):
#         """Инициализирует атрибуты класса-родителя.
#         Затем инициализируем атрибуты, специфические для электромобиля."""
#         super().__init__(make, model, year)
#         self.battery = Battery()  # 4
#
#     def fill_gas_tank(self):
#         """У электромобиля нет бензобака."""
#         print("Этой машине не нужен бензобак!")
#
#
# print("Сделайте электромобиль и проверьте аккумулятор:")
# my_tesla = ElectricCar('tesla', 'model s', 2016)
# print("\t********************")
# print(my_tesla.get_descriptive_name())
# my_tesla.battery.describe_battery()
#
# print("\nОбновите аккумулятор и проверьте еще раз:")
# my_tesla.battery.upgrade_battery()
# my_tesla.battery.describe_battery()
#
# print("\nПопробуйте обновить аккумулятор во второй раз.")
# my_tesla.battery.upgrade_battery()
# my_tesla.battery.describe_battery()
# print(" ")
# my_tesla.fill_gas_tank()
# my_tesla.battery.get_range()

# -------------------------------------------------------------------------------------------------------------------

# Импортирование одного класса

# Начнем с создания модуля, содержащего только класс Car. При этом возникает
# неочевидный конфликт имен: в этой главе уже был создан файл с именем car.py,
# но этот модуль тоже должен называться car.py, потому что в нем содержится
# код класса Car. Мы решим эту проблему, сохранив класс Car в модуле с именем
# car.py, заменив им файл car.py, который использовался ранее. В дальнейшем
# любой программе, использующей этот модуль, придется присвоить более кон-
# кретное имя файла — например, my_car.py. Ниже приведен файл car.py с кодом
# класса Car:


# В точке  включается строка документации уровня модуля с кратким описанием
# содержимого модуля. Пишите строки документации для каждого созданного вами
# модуля.
# Теперь мы создадим отдельный файл с именем my_car.py. Этот файл импортирует
# класс Car и создает экземпляр этого класса:

# from car import Car   # 1
#
# my_new_car = Car('audi', 'a4', 2016)
# print(my_new_car.get_descriptive_name())
#
# my_new_car.odometer_read = 23
# my_new_car.read_odometer()


# Команда import в точке  приказывает Python открыть модуль car и импорти-
# ровать класс Car. Теперь мы можем использовать класс Car так, как если бы он
# был определен в этом файле. Результат остается тем же, что и в предыдущей
# версии:

# Импортирование классов повышает эффективность программирования. Пред-
# ставьте, каким длинным получился бы файл этой программы, если бы в него был
# включен весь класс Car. Перемещая класс в модуль и импортируя этот модуль,
# вы получаете ту же функциональность, но основной файл программы при этом
# остается чистым и удобочитаемым. Бульшая часть логики также может храниться
# в отдельных файлах; когда ваши классы работают так, как положено, вы можете
# забыть об этих файлах и сосредоточиться на высокоуровневой логике основной
# программы.

# ---------------------------------------------------------------------------------------------------------------------

# Хранение нескольких классов в модуле

# В одном модуле можно хранить сколько угодно классов, хотя все эти классы долж-
# ны быть каким-то образом связаны друг с другом. Оба класса Battery и ElectricCar
# используются для представления автомобилей, поэтому мы добавим их в модуль

# from car import ElectricCar
#
# my_tesla = ElectricCar('tesla', 'model s', 2016)
#
# print(my_tesla.get_descriptive_name())
# my_tesla.battery.describe_battery()
# my_tesla.battery.get_range()

# ---------------------------------------------------------------------------------------------------------------------

# Импортирование нескольких классов из модуля

# В файл программы можно импортировать столько классов, сколько потребуется.
# Если вы захотите создать обычный автомобиль и электромобиль в одном файле,
# потребуется импортировать оба класса, Car и ElectricCar:
# my_cars.py


# from car import Car, ElectricCar  # 
#
# my_beetle = Car('volkswagen', 'beetle', 2016)  # 
# print(my_beetle.get_descriptive_name())
# my_tesla = ElectricCar('tesla', 'roadster', 2016)  # 
# print(my_tesla.get_descriptive_name())

# Чтобы импортировать несколько классов из модуля, разделите их имена запя-
# тыми . После того как необходимые классы будут импортированы, вы можете
# создать столько экземпляров каждого класса, сколько потребуется.
# В этом примере создается обычный автомобиль Volkswagen Beetle  и электро-
# мобиль Tesla Roadster :

# --------------------------------------------------------------------------------------------------------------------

# Импортирование всего модуля

# Также возможно импортировать весь модуль, а потом обращаться к нужным клас-
# сам с использованием точечной записи. Этот способ прост, а полученный код легко
# читается. Так как каждый вызов, создающий экземпляр класса, включает имя моду-
# ля, в программе не будет конфликтов с именами, используемыми в текущем файле.

# import car  # 
#
# my_beetle = car.Car('volkswagen', 'beetle', 2016)  # 
# print(my_beetle.get_descriptive_name())
# my_tesla = car.ElectricCar('tesla', 'roadster', 2016)  # 
# print(my_tesla.get_descriptive_name())


# В точке  импортируется весь модуль car, после чего программа обращает-
# ся к нужным классам с использованием синтаксиса имя_модуля.имя_класса.
# В точке  снова создается экземпляр Volkswagen Beetle, а в точке  — экземпляр
# Tesla Roadster.

# ---------------------------------------------------------------------------------------------------------------------

# Импортирование всех классов из модуля

# Для импортирования всех классов из модуля используется следующий синтаксис:

# from имя_модуля import *

# Использовать этот способ не рекомендуется по двум причинам. Прежде всего,
# бывает полезно прочитать команды import в начале файла и получить четкое пред-
# ставление о том, какие классы используются в программе, а при таком подходе
# неясно, какие классы из модуля нужны программе. Также возможны конфликты
# с именами в файле. Если вы случайно импортируете класс с именем, уже при-
# сутствующим в файле, в программе могут возникнуть коварные ошибки. Почему
# я привожу описание этого способа? Хотя использовать его не рекомендуется, ско-
# рее всего, вы встретите его в коде других разработчиков.
# Итак, если вам нужно импортировать большое количество классов из модуля,
# лучше импортировать весь модуль и воспользоваться синтаксисом имя_модуля.
# имя_класса. Хотя вы не видите перечень всех используемых классов в начале
# файла, по крайней мере ясно видно, где модуль используется в программе. Также
# предотвращаются потенциальные конфликты имен, которые могут возникнуть при
# импортировании каждого класса в модуле.

# ---------------------------------------------------------------------------------------------------------------------

# Импортирование модуля в модуль

# Иногда классы приходится распределять по нескольким модулям, чтобы избежать
# чрезмерного разрастания одного файла и хранения несвязанных классов в одном
# модуле. При хранении классов в нескольких модулях может оказаться, что один
# класс из одного модуля зависит от класса из другого модуля. В таких случаях не-
# обходимый класс можно импортировать в первый модуль.
# Допустим, класс Car хранится в одном модуле, а классы ElectricCar и Battery —
# в другом. Мы создадим новый модуль с именем electric_car.py (он заменит файл
# electric_car.py, созданный ранее) и скопируем в него только классы Battery
# и ElectricCar:
# electric_car.py
# """Набор классов для представления электромобилей."""
#  from car import Car
# class Battery():
# ...
# class ElectricCar(Car):
# ...
# Классу ElectricCar необходим доступ к классу-родителю Car, поэтому класс Car
# импортируется прямо в модуль в точке . Если вы забудете вставить эту команду,
# при попытке создания экземпляра ElectricCar произойдет ошибка. Также необ-
# ходимо обновить модуль Car, чтобы он содержал только класс Car:
# car.py
# """Простая модель автомобиля."""
# class Car():
# ...
# Теперь вы можете импортировать классы из каждого модуля по отдельности
# и создать
# ту разновидность машины, которая вам нужна:
# my_cars.py
#
#
#  from car import Car
# from electric_car import ElectricCar
# my_beetle = Car('volkswagen', 'beetle', 2016)
# print(my_beetle.get_descriptive_name())
# my_tesla = ElectricCar('tesla', 'roadster', 2016)
# print(my_tesla.get_descriptive_name())
#
#
# В точке  класс Car импортируется из своего модуля, а класс ElectricCar — из сво-
# его. После этого создаются экземпляры обоих разновидностей. Вывод показывает,
# что экземпляры были созданы правильно:

# --------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 9-10. Импортирование класса Restaurant: возьмите последнюю версию класса Restaurant
# и сохраните ее в модуле. Создайте отдельный файл, импортирующий класс Restaurant.
# Создайте экземпляр Restaurant и вызовите один из методов Restaurant, чтобы показать, что
# команда import работает правильно.
# 9-11. Импортирование класса Admin: начните с версии класса из упражнения 9-8 (с.176).
# Сохраните классы User, Privileges и Admin в одном модуле. Создайте отдельный файл, соз-
# дайте экземпляр Admin и вызовите метод show_privileges(), чтобы показать, что все рабо-
# тает правильно.
# 9-12. Множественные модули: сохраните класс User в одном модуле, а классы Privileges
# и Admin в другом модуле. В отдельном файле создайте экземпляр Admin и вызовите метод
# show_privileges(), чтобы показать, что все работает правильно.


# ----------------------------------------------------------------------------------------------------------------------

# Стандартная библиотека Python

# Стандартная библиотека Python представляет собой набор модулей, включаемых
# в каждую установленную копию Python. Сейчас вы уже примерно понимаете, как
# работают классы, и можете начать использовать модули, написанные другими
# программистами. Чтобы использовать любую функцию или класс из стандартной
# библиотеки, достаточно включить простую команду import в начало файла. Для
# примера рассмотрим класс OrderedDict из модуля collections.
# Как вы уже знаете, словари позволяют связывать информационные фрагменты, но
# они не отслеживают порядок добавления пар «ключ—значение». Если вы хотите
# создать словарь, но при этом сохранить порядок добавления пар «ключ—значение»,
# воспользуйтесь классом OrderedDict из модуля collections. Экземпляры класса
# OrderedDict ведут себя практически так же, как и словари, если не считать того, что
# они отслеживают порядок добавления пар «ключ—значение».
# Вернемся к примеру favorite_languages.py из главы 6. На этот раз программа будет
# отслеживать порядок, в котором участники отвечают на опрос:

# from collections import OrderedDict     # 1
# favorite_languages = OrderedDict()      # 2
# favorite_languages["jen"] = "python"    # 3
# favorite_languages["sarah"] = "с"
# favorite_languages["edward"] = "ruby"
# favorite_languages["phil"] = "python"
# for name, languages in favorite_languages.items():   # 4
#     print(name.title() + " любимые языки " + languages.title() + ".")

# Сначала программа импортирует класс OrderedDict из модуля collections в точ-
# ке . В точке  создается экземпляр класса OrderedDict, который сохраняется
# в favorite_languages. Обратите внимание на отсутствие фигурных скобок; вызов
# OrderedDict() создает пустой упорядоченный словарь и сохраняет его в favorite_
# languages. Затем пары из имени и языка последовательно добавляются в словарь .
# Теперь при переборе favorite_languages в точке  данные всегда будут выдаваться
# в порядке их добавления:

# ПРИМЕЧАНИЕ
# Модули также можно загружать из внешних источников. Соответствующие примеры встретятся
# вам в части II, в которой для завершения работы над проектами мы будем использовать внешние
# модули.

# --------------------------------------------------------------------------------------------------------------------
# с.183
# УПРАЖНЕНИЯ
# 9-13. Переработка с OrderedDict Rewrite: начните с упражнения 6-4 (с. 113), в котором
# стандартный словарь используется для представления глоссария. Перепишите программу
# с использованием класса OrderedDict и убедитесь в том, что порядок вывода совпадает
# с порядком добавления пар «ключ—значение» в словарь.


# from collections import OrderedDict
#
# golosary = OrderedDict()
# golosary = {
#     "конкатэнация": "cложение",
#     "коммит": "сохранять скрин кода",
#     "пушить": "скидывать на свервер",
#     "пулить": "скачивать с сервера",
#     "итерация": "повторение",
# }
#
# # from collections import OrderedDict
# #
# # golosary = OrderedDict()
# golosary['string'] = 'строка'
# golosary['len'] = 'кол-во символов'
# golosary['integer'] = 'целое число'
# golosary['slices'] = 'срезы'
#
# for key, value in golosary.items():
#     print(key, ":", value)

# --------------------------------------------------------------------------------------------------------------------

# 9-14. Кубики: модуль random содержит функции для генерирования случайных чисел раз-
# ными способами. Функция randint() возвращает целое число в заданном диапазоне. Следу-
# ющий код возвращает число от 1 до 6:
# from random import randint
# x = randint(1, 6)
# Создайте класс Die с одним атрибутом с именем sides, который содержит значение по умол-
# чанию 6. Напишите метод roll_die() для вывода случайного числа от 1 до количества сторон
# кубика. Создайте экземпляр, моделирующий 6-гранный кубик, и имитируйте 10 бросков.
# Создайте модели 10- и 20-гранного кубика. Имитируйте 10 бросков каждого кубика.

# from random import randint
#
# x = randint(1, 6)
#
#
# class Die():
#     """Представим себе кубик, который можно катить"""
#
#     def __init__(self, sides=6):
#         """Стороны кубика"""
#         self.sides = sides
#
#     def roll_die(self):
#         """Бросок кубика"""
#         return randint(1, self.sides)


#  Сделайте шестигранный кубик и покажите результаты 10 бросков.
# d6 = Die()
#
# results = []
# for roll_num in range(10):
#     result = d6.roll_die()
#     results.append(result)
# print("\n10 бросков 6-тигранного кубика: ")
# print(results)

# ----------------------------------------------------------------

# d6 = Die(sides=10)
#
# results = []
# for roll_num in range(10):
#     result = d6.roll_die()
#     results.append(result)
# print("\n10 бросков 10-тигранного кубика: ")
# print(results)

# ---------------------------------------------------------------------------------------------------------------------

# d6 = Die(sides=20)
#
# results = []
# for roll_num in range(10):
#     result = d6.roll_die()
#     results.append(result)
# print("\n10 бросков 20-тигранного кубика: ")
# print(results)

# ---------------------------------------------------------------------------------------------------------------------

# 9-15. Модуль недели: для знакомства со стандартной библиотекой Python отлично подой-
# дет сайт Python Module of the Week. Откройте сайт http://pymotw.com/ и просмотрите оглав-
# ление. Найдите модуль, который покажется вам интересным, и прочитайте про него или
# изучите документацию по модулям collections и random.

# ---------------------------------------------------------------------------------------------------------------------

