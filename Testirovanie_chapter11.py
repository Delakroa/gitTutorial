# 11 Тестирование

# Вместе с функциями и классами вы также можете написать тесты для своего кода.
# Тестирование доказывает, что код работает так, как положено, для любых разно-
# видностей входных данных, которые он может получать. Тесты позволят вам быть
# уверенным в том, что код будет работать правильно и тогда, когда вашими про-
# граммами станут пользоваться другие люди. Тестирование при добавлении нового
# кода гарантирует, что внесенные изменения не повлияют на текущее поведение
# программы. Все программисты допускают ошибки, поэтому каждый программист
# должен часто тестировать свой код и выявлять ошибки до того, как с ними столкнутся
# другие пользователи.
# В этой главе вы научитесь тестировать код средствами модуля Python unittest.
# Вы узнаете, как построить тестовые сценарии, как проверить, выдает ли программа
# для конкретных входных данных ожидаемый результат и как тестировать функ-
# ции и классы. Также вы научитесь оценивать, сколько тестов нужно написать для
# проекта.

# ---------------------------------------------------------------------------------------------------------------------

# Тестирование функции

# Чтобы потренироваться в тестировании, нам понадобится код. Ниже приведена
# простая функция, которая получает имя и фамилию и возвращает отформатиро-
# ванное полное имя:

# def get_formatted_name(first, last):
#     """Строит отформатированное полное имя"""
#     full_name = first + ' ' + last
#     return full_name.title()


# Функция get_formatted_name() строит полное имя из имени и фамилии, разде-
# лив их пробелом, преобразует первый символ каждого слова к верхнему регистру
# и возвращает полученный результат. Чтобы убедиться в том, что функция get_
# formatted_name() работает правильно, мы напишем программу, использующую
# эту функцию. Программа names.py запрашивает у пользователя имя и фамилию
# и выдает отформатированное полное имя:

# from name_function import get_formatted_name


# print("Введите 'q' для выхода в любое время. ")
# while True:
#     first = input("Пожалуйста введите ваше имя: ")
#     if first == "q":
#         break
#     last = input("Введите пожалуйста вашу фамилию: ")
#     print("")
#     if last == "q":
#         break
#     formatted_name = get_formatted_name(first, last)
#     print("\tАккуратно отформатированное имя: " + formatted_name + '.')

# Программа импортирует функцию g e t _ f o r m a t t e d _ n a m e ( ) из модуля

# name_function.py. Пользователь вводит последовательность имен и фамилий
# и видит,
# что программа сгенерировала отформатированные полные имена:
#
#
# Enter 'q' at any time to quit.
# Please give me a first name: janis
# Please give me a last name: joplin
# Neatly formatted name: Janis Joplin.
# Please give me a first name: bob
# Please give me a last name: dylan
# Neatly formatted name: Bob Dylan.
# Please give me a first name: q

# Как видно из листинга, имена сгенерированы правильно. Но допустим, вы решили
# изменить функцию get_formatted_name(), чтобы она также работала со вторыми
# именами. При этом необходимо проследить за тем, чтобы функция не перестала
# правильно работать для имен, состоящих только из имени и фамилии. Чтобы про-
# тестировать код, можно запустить names.py и для проверки вводить имя из двух
# компонентов (скажем, Janis Joplin) при каждом изменении get_formatted_name(),
# но это довольно утомительно. К счастью, Python предоставляет эффективный
# механизм автоматизации тестирования вывода функций. При автоматизации те-
# стирования get_formatted_name() вы будете уверены в том, что функция успешно
# работает для всех видов имен, для которых написаны тесты.

# -------------------------------------------------------------------------------------------------------------------

# Прохождение теста

# Вы не сразу привыкнете к синтаксису создания тестовых сценариев, но после того,
# как тестовый сценарий будет создан, вы сможете легко добавить новые модульные
# тесты для своих функций. Чтобы написать тестовый сценарий для функции, импор-
# тируйте модуль unittest и функцию, которую необходимо протестировать. Затем
# создайте класс, наследующий от unittest.TestCase, и напишите серию методов для
# тестирования различных аспектов поведения своей функции.
# Ниже приведен тестовый сценарий с одним методом, который проверяет, что функ-
# ция get_formatted_name() правильно работает при передаче имени и фамилии:

# import unittest
# from Testirovanie_chapter11 import get_formatted_name
#
#
# class NamesTestCase(unittest.TestCase):   # 1
#     """Тесты дял 'Testirovanie_chapter11.py'."""
#
#     def test_first_last_name(self):
#         """Имена вида 'Janis Joplin' работают правильно?"""
#         formatted_name = get_formatted_name('janis', 'joplin')   # 2
#         self.assertEqual(formatted_name, 'Janis Joplin')    # 3
#
#
# unittest.main()

# Сначала мы импортируем unittest и тестируемую функцию get_formatted_name().
# В точке  создается класс NamesTestCase, который содержит серию модульных
# тестов для get_formatted_name(). Имя класса выбирается произвольно, но лучше
# выбрать имя, связанное с функцией, которую вы собираетесь тестировать, и вклю-
# чить в имя класса слово Test. Этот класс должен наследовать от класса unittest.
# TestCase, чтобы Python знал, как запустить написанные вами тесты.
# Класс NamesTestCase содержит один метод, который тестирует всего один аспект
# get_formatted_name() — правильность форматирования имен, состоящих только из
# имени и фамилии. Мы назвали этот метод test_first_last_name(). Любой метод,
# имя которого начинается с test_, будет выполняться автоматически при запуске
# test_name_function.py. В тестовом методе вызывается тестируемая функция и сохра-
# няется возвращаемое значение, которое необходимо проверить. В данном примере
# вызывается функция get_formatted_name() с аргументами 'janis' и 'joplin',
# а результат сохраняется в переменной formatted_name .
# В точке  используется одна из самых полезных особенностей unittest: метод
# assert. Методы assert проверяют, что полученный результат соответствует тому
# результату, который вы рассчитывали получить. В данном случае известно, что
# функция get_formatted_name() должна вернуть полное имя с пробелами и капита-
# лизацией слов, поэтому переменная formatted_name должна содержать текст «Janis
# Joplin». Чтобы убедиться в этом, мы используем метод assertEqual() из модуля
# unittest и передаем ему переменную formatted_name и строку 'Janis Joplin'.
# Вызов
# self.assertEqual(formatted_name, 'Janis Joplin')
# означает: «Сравни значение formatted_name со строкой 'Janis Joplin'. Если они
# равны, как и ожидалось, — хорошо. Но если они не равны, обязательно сообщи
# мне!»
# Строка unittest.main() приказывает Python выполнить тесты из этого файла.
# При запуске test_name_function.py будет получен следующий результат:
# .
# ----------------------------------------------------------------------
# Ran 1 test in 0.000s
# OK
#
# Точка в первой строке вывода сообщает, что один тест прошел успешно. Следу-
# ющая строка говорит, что для выполнения одного теста Python потребовалось
# менее 0,001 секунды. Наконец, завершающее сообщение OK говорит о том, что все
# модульные тесты в тестовом сценарии прошли.
# Этот результат показывает, что функция get_formatted_name() успешно работает
# для полных имен, состоящих из имени и фамилии, если только функция не была
# изменена. В случае внесения изменений в get_formatted_name() тест можно запу-
# стить снова. И если тестовый сценарий снова пройдет, мы будем знать, что функция
# продолжает успешно работать с полными именами из двух компонентов.

# --------------------------------------------------------------------------------------------------------------------

# Сбой теста

# Как выглядит сбойный тест? Попробуем изменить функцию get_formatted_name(),
# чтобы она работала со вторыми именами, — но сделаем это так, чтобы она перестала
# работать с полными именами из двух компонентов.
# Новая версия get_formatted_name() с дополнительным аргументом второго имени
# выглядит так:


# def get_formatted_name(first, middle, last):
#     """Строит отформатированное полное имя."""
#     full_name = first + ' ' + middle + ' ' + last
#     return full_name.title()


# Эта версия должна работать для полных имен из трех компонентов, но тестирова-
# ние показывает, что она перестала работать для полных имен из двух компонентов.
# На этот раз файл test_name_function.py выдает следующий результат:


#  E
# ======================================================================
#  ERROR: test_first_last_name (__main__.NamesTestCase)
# ----------------------------------------------------------------------
#  Traceback (most recent call last):
# File "test_name_function.py", line 8, in test_first_last_name
# formatted_name = get_formatted_name('janis', 'joplin')
# TypeError: get_formatted_name() missing 1 required positional argument: 'last'
# ----------------------------------------------------------------------
#  Ran 1 test in 0.000s
#  FAILED (errors=1)


# На этот раз информации гораздо больше, потому что при сбое теста разработчик
# должен знать, почему это произошло. Вывод начинается с одной буквы E , которая
# сообщает, что один модульный тест в тестовом сценарии привел к ошибке. Затем мы
# видим, что ошибка произошла в тесте test_first_last_name() в NamesTestCase .
# Конкретная информация о сбойном тесте особенно важна в том случае, если тестовый
# сценарий состоит из нескольких модульных тестов. В точке  мы видим стандартную
# трассировку, из которой понятно, что вызов функции get_formatted_name('janis',
# 'joplin') перестал работать из-за необходимого позиционного аргумента.
# Также из вывода следует, что был выполнен один модульный тест . Наконец, до-
# полнительное сообщение информирует, что тестовый сценарий в целом не прошел
# и произошла одна ошибка при выполнении тестового сценария . Эта информация
# размещается в конце вывода, чтобы она была видна сразу; разработчику не придется
# прокручивать длинный протокол, чтобы узнать количество сбойных тестов.

# ---------------------------------------------------------------------------------------------------------------------

# Реакция на сбойный тест

# Что делать, если тест не проходит? Если предположить, что проверяются правильные
# условия, прохождение теста означает, что функция работает правильно, а сбой — что
# в новом коде добавилась ошибка. Итак, если тест не прошел, изменять нужно не тест,
# а код, который привел к сбою теста. Проанализируйте изменения, внесенные в функ-
# цию, и разберитесь, как они привели к нарушению ожидаемого поведения.
# В данном случае у функции get_formatted_name() было всего два обязательных
# параметра: имя и фамилия. Теперь она требует три обязательных параметра: имя,
# второе имя и фамилию. Добавление обязательного параметра для второго имени
# нарушило ожидаемое поведение get_formatted_name(). В таком случае лучше все-
# го сделать параметр второго имени необязательным. После этого тесты для имен
# с двумя компонентами снова будут проходить, и программа сможет получать также
# вторые имена. Изменим функцию get_formatted_name(), чтобы параметр второго
# имени перестал быть обязательным, и снова выполним тестовый сценарий. Если
# он пройдет, можно переходить к проверке правильности обработки вторых имен.
# Чтобы сделать второе имя необязательным, нужно переместить параметр middle
# в конец списка параметров в определении функции и задать ему пустое значение
# по умолчанию. Также будет добавлена проверка if, которая правильно строит
# полное имя в зависимости от того, передается второе имя или нет:

# def get_formatted_name(first, last, middle=''):
#     """Строит отформатированное полное имя."""
#     if middle:
#         full_name = first + ' ' + middle + ' ' + last
#     else:
#         full_name = first + ' ' + last
#     return full_name.title()


# В новой версии get_formatted_name() параметр middle не обязателен. Если второе
# имя передается функции (if middle:), то полное имя будет содержать имя, второе
# имя и фамилию. В противном случае полное имя состоит только из имени и фа-
# милии. Теперь функция должна работать для обеих разновидностей имен. Чтобы
# узнать, работает ли функция для имен из двух компонентов, снова запустите
# test_name_function.py:

# .
# ----------------------------------------------------------------------
# Ran 1 test in 0.000s
# OK

# Теперь тестовый сценарий проходит. Такой исход идеален; он означает, что функ-
# ция снова работает для имен из двух компонентов и нам не пришлось тестировать
# функцию вручную. Исправить ошибку было несложно, потому что сбойный тест
# помог выявить новый код, нарушивший существующее поведение.

# ---------------------------------------------------------------------------------------------------------------------

# Добавление новых тестов

# Теперь мы знаем, что get_formatted_name() работает для простых имен, и мо-
# жем написать второй тест для имен из трех компонентов. Для этого в класс
# NamesTestCase добавляется еще один метод:

# import unittest
# from Testirovanie_chapter11 import get_formatted_name
#
#
# class NamesTestCase(unittest.TestCase):
#     """Тесты для 'Testirovanie_chapter11.py'."""
#
#     def test_first_last_name(self):
#         """Имена вида 'Janis Joplin' работают правильно?"""
#         formatted_name = get_formatted_name('janis', 'joplin')
#         self.assertEqual(formatted_name, 'Janis Joplin')
#
#     def test_first_last_middle_name(self):
#         """Работают ли такие имена, как 'Wolfgang Amadeus Mozart ?'"""
#         formatted_name = get_formatted_name('wolfgang', 'mozart', 'amadeus')   # 1
#         self.assertEqual(formatted_name, 'Wolfgang Amadeus Mozart')
#
#
# if __name__ == '__main__':
#     unittest.main()


# Новому методу присваивается имя test_first_last_middle_name(). Имя метода
# должно начинаться с test_, чтобы этот метод выполнялся автоматически при запуске
# test_name_function.py. В остальном имя выбирается так, чтобы оно четко показывало,
# какое именно поведение get_formatted_name() мы тестируем. В результате при сбое
# теста вы сразу видите, к каким именам он относится. Не нужно опасаться длинных
# имен методов в классах TestCase: имена должны быть содержательными, чтобы до-
# нести информацию до разработчика в случае сбоя, а поскольку Python вызывает их
# автоматически, вам никогда не придется вручную вводить эти имена при вызове.
# Чтобы протестировать функцию, мы вызываем get_formatted_name() c тремя
# компонентами , после чего используем assertEqual() для проверки того, что
# возвращенное полное имя совпадает с ожидаемым. При повторном запуске test_
# name_function.py оба теста проходят успешно:

# Testing started at 13:25 ...
#
#
# Ran 2 tests in 0.002s
#
# OK

# Отлично! Теперь мы знаем, что функция по-прежнему работает с именами
# из двух компонентов, как Janis Joplin, но можем быть уверены в том, что она
# сработает и для имен с тремя компонентам — такими, как Wolfgang Amadeus
# Mozart.

# ---------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ

# 11-1. Город, страна: напишите функцию, которая получает два параметра: название
# страны и название города. Функция должна возвращать одну строку в формате «Го-
# род, Страна», например «Santiago, Chile». Сохраните функцию в модуле с именем city_
# functions.py.
# Создайте файл test_cities.py для тестирования только что написанной функции (не забудьте
# импортировать unittest и тестируемую функцию). Напишите метод test_city_country() для
# проверки того, что вызов функции с такими значениями, как ‘santiago’ и ‘chile’, дает пра-
# вильную строку. Запустите test_cities.py и убедитесь в том, что тест test_city_country() про-
# ходит успешно.

# def description_cities(country, city):
#     """Название страны и города"""
#     full_description = country + ' ' + city
#     return full_description.title()

# ---------------------------------------------------------------------------------------------------------------------

# 11-2. Население: измените свою функцию так, чтобы у нее был третий обязательный
# параметр — население. В новой версии функция должна возвращать одну строку вида
# «Santiago, Chile — population 5000000.» Снова запустите программу test_cities.py. Убедитесь
# в том, что тест test_city_country() на этот раз не проходит.
# Измените функцию так, чтобы параметр населения стал необязательным. Снова запустите
# test_cities.py и убедитесь в том, что тест test_city_country() проходит успешно.
# Напишите второй тест test_city_country_population(), который проверяет вызов функции
# со значениями ‘santiago’, ‘chile’ и ‘population=5000000’. Снова запустите test_cities.py и убе-
# дитесь в том, что новый тест проходит успешно.

# def description_cities(country, city, population=5000000):
#     """Название страны и города"""
#     if population:
#         full_description = country + ' ' + city + ' ' + str(population)
#     else:
#         full_description = country + ' ' + city
#     return full_description.title()


# ---------------------------------------------------------------------------------------------------------------------

# Тестирование класса

# В первой части этой главы мы писали тесты для отдельной функции. Сей-
# час мы займемся написанием тестов для класса. Классы будут использовать-
# ся во многих ваших программах, поэтому возможность доказать, что ваши
# классы
# работают правильно, будет безусловно полезной. Если тесты для класса,
# над которым
# вы работаете, проходят успешно, вы можете быть уверены в том,
# что усовершенствования класса не приведут к случайному нарушению его те-
# кущего поведения.

# Разные методы assert

# Класс unittest.TestCase содержит целое семейство проверочных методов assert.
# Как упоминалось ранее, эти методы проверяют, выполняется ли условие, которое
# должно выполняться в определенной точке вашего кода. Если условие истинно,
# как и предполагалось, то ваши ожидания относительно поведения части вашей
# программы подтверждаются; вы можете быть уверены в отсутствии ошибок. Если
# же условие, которое должно быть истинным, окажется ложным, то Python выдает
# исключение.
# В табл. 11.1 перечислены шесть часто используемых методов assert. С их помощью
# можно проверить, что возвращаемые значения равны или не равны ожидаемым,
# что значения равны True или False или что значения входят или не входят в за-
# данный список. Эти методы могут использоваться только в классах, наследующих
# от unittest.TestCase; рассмотрим пример использования такого метода в контексте
# тестирования реального класса.

# Таблица 11.1. Методы assert, предоставляемые модулем unittest

# Метод Использование
# assertEqual(a, b) Проверяет, что a == b
# assertNotEqual(a, b) Проверяет, что a != b
# assertTrue(x) Проверяет, что значение x истинно
# assertFalse(x) Проверяет, что значение x ложно
# assertIn(элемент, список) Проверяет, что элемент входит в список
# assertNotIn(элемент, список) Проверяет, что элемент не входит в список

# --------------------------------------------------------------------------------------------------------------------

# Класс для тестирования
#
# Тестирование класса имеет много общего с тестированием функции — значитель-
# ная часть работы направлена на тестирование поведения методов класса. Впрочем,
# существуют и различия, поэтому мы напишем отдельный класс для тестирования.
# Возьмем класс для управления проведением анонимных опросов:


# class AnonymousSurvey():
#     """Сбор анонимных ответов на порос."""
#
#     def __init__(self, question):  # 1
#         """Сохраняет вопрос и готовится к сохранению ответа."""
#         self.question = question
#         self.responses = []
#
#     def show_question(self):  # 2
#         """Выводит вопрос."""
#         print(self.question)
#
#     def store_response(self, new_response):  # 3
#         """Сохраняет один ответ на вопрос."""
#         self.responses.append(new_response)
#
#     def show_results(self):  # 4
#         """Выводит все полученные ответы. """
#         print("Результаты опроса:")
#         for self.response in self.responses:
#             print("- " + self.response)

# Класс начинается с вопроса, предоставленного администратором , и включает
# пустой список для хранения ответов. Класс содержит методы для вывода вопроса , добавления нового ответа в список
# ответов  и вывода всех ответов,
# хранящихся в списке . Чтобы создать экземпляр на основе этого класса, необходимо предоставить вопрос.
# После того как будет создан экземпляр, представляющий конкретный опрос, программа выводит вопрос методом show_
# question(), сохраняет ответ методом store_response() и выводит результаты
# вызовом show_results().
# Чтобы продемонстрировать, что класс AnonymousSurvey работает, напишем программу, которая использует этот класс:


# from Testirovanie_chapter11 import AnonymousSurvey
#
# # определение опроса с сохданием экземпляра AnonymousSurvey
# question = "На каком языке вы впервые научились говорить?"
# my_survey = AnonymousSurvey(question)
#
# # Вывод вопроса и сохранение ответов.
# my_survey.show_question()
# print("Введите 'q' в любое время бросить.\n")
# while True:
#     response = input("Язык: ")
#     if response == 'q':
#         break
#     my_survey.store_response(response)
# # Вывод результатов опроса.
# print("\nСпасибо всем, кто участвовал в опросе!")
# my_survey.show_results()

# Программа определяет вопрос и создает объект AnonymousSurvey на базе этого вопроса. Программа вызывает метод
# show_question() для вывода вопроса, после чегопереходит к получению ответов. Каждый ответ сохраняется сразу же при
# получении. Когда ввод ответов был завершен (пользователь ввел q), метод show_results()
# выводит результаты опроса:

# What language did you first learn to speak?
# Enter 'q' at any time to quit.
# Language: English
# Language: Spanish
# Language: English
# Language: Mandarin
# Language: q
#
# Thank you to everyone who participated in the survey!
# Survey results:
#
# - English
# - Spanish
# - English
# - Mandarin

# Этот класс работает для простого анонимного опроса. Но допустим, вы решили
# усовершенствовать класс AnonymousSurvey и модуль survey, в котором он находится.
# Например, каждому пользователю будет разрешено ввести несколько ответов.
# Или вы напишете метод, который будет выводить только уникальные ответы
# и сообщать, сколько раз был дан тот или иной ответ. Или вы напишете другой класс
# для проведения неанонимных опросов.
# Реализация таких изменений грозит повлиять на текущее поведение класса
# AnonymousSurvey. Например, может оказаться, что поддержка ввода нескольких
# ответов случайно повлияет на процесс обработки одиночных ответов. Чтобы гарантировать,
# что доработка модуля не нарушит существующего поведения, для
# класса нужно написать тесты.

# --------------------------------------------------------------------------------------------------------------------

# Тестирование класса AnonymousSurvey
#
# class AnonymousSurvey():
#     """Сбор анонимных ответов на порос."""
#
#     def __init__(self, question):  # 1
#         """Сохраняет вопрос и готовится к сохранению ответа."""
#         self.question = question
#         self.responses = []
#
#     def show_question(self):  # 2
#         """Выводит вопрос."""
#         print(self.question)
#
#     def store_response(self, new_response):  # 3
#         """Сохраняет один ответ на вопрос."""
#         self.responses.append(new_response)
#
#     def show_results(self):  # 4
#         """Выводит все полученные ответы. """
#         print("Результаты опроса:")
#         for self.response in self.responses:
#             print("- " + self.response)


# import unittest
# from language_survey import AnonymousSurvey
#
#
# class TestAnonymousSurvey(unittest.TestCase):  # 1
#     """Тесты для класса AnonymousSurvey"""
#
#     def test_store_single(self):   # 2
#         """Проверяет что один ответ сохранён правильно"""
#         question = "На каком языке вы впервые научились говорить?"
#         my_survey = AnonymousSurvey(question)  # 3
#         my_survey.store_response('English')
#
#         self.assertIn('English', my_survey.responses)   # 4
#
# Программа начинается с импортирования модуля unittest и тестируемого класса
# AnonymousSurvey. Тестовый сценарий TestAnonymousSurvey, как и в предыдущих
# случаях, наследует от unittest.TestCase . Первый тестовый метод проверяет, что
# сохраненный ответ действительно попадает в список ответов опроса. Этому методу
# присваивается хорошее содержательное имя test_store_single_response() .
# Если тест не проходит, имя метода в выходных данных сбойного теста ясно пока-
# зывает, что проблема связана с сохранением отдельного ответа на опрос.
# Чтобы протестировать поведение класса, необходимо создать экземпляр класса.
# В точке  создается экземпляр с именем my_survey для вопроса "What language
# did you first learn to speak?", Один ответ (English) сохраняется с использова-
# нием метода store_response(). Затем программа убеждается в том, что ответ был
# сохранен правильно; для этого она проверяет, что значение English присутствует
# в списке my_survey.responses .
# При запуске программы test_survey.py тест проходит успешно:
# .
# ----------------------------------------------------------------------
# Ran 1 test in 0.001s
# OK
# Неплохо, но опрос с одним ответом вряд ли можно назвать полезным. Убедимся
# в том, что три ответа сохраняются правильно. Для этого в TestAnonymousSurvey
# добавляется еще один метод:

#      def test_store_three_responses(self):
#         """Проверяет, что три ответа были сохранены правильно."""
#         question = "На каком языке вы впервые научились говорить?"
#         my_survey = AnonymousSurvey(question)
#         responses = ['English', 'Spanish', 'Mandarin']  # 1
#         for response in responses:
#             my_survey.store_response(response)
#
#         for response in responses:   # 2
#             self.assertIn(response, my_survey.responses)
#
# if __name__ == '__main__':
#     unittest.main()

# Новому методу присваивается имя test_store_three_responses(). Мы создаем
# объект опроса по аналогии с тем, как это делалось в test_store_single_response().
# Затем определяется список, содержащий три разных ответа , и для каждого из
# этих ответов вызывается метод store_response(). После того как ответы будут
# сохранены, следующий цикл проверяет, что каждый ответ теперь присутствует
# в my_survey.responses .
# Если снова запустить test_survey.py, оба теста (для одного ответа и для трех ответов)
# проходят успешно:
# ..
# ----------------------------------------------------------------------
# Ran 2 tests in 0.000s
# OK
# Все прекрасно работает. Тем не менее тесты выглядят немного однообразно, по-
# этому мы воспользуемся еще одной возможностью unittest для повышения их
# эффективности.


# --------------------------------------------------------------------------------------------------------------------

# Метод setUp()

# В программе test_survey.py в каждом тестовом методе создавался новый экземпляр
# AnonymousSurvey, а также новые ответы. Класс unittest.TestCase содержит метод
# Тестирование класса 221
# setUp(), который позволяет создать эти объекты один раз, а затем использовать их
# в каждом из тестовых методов. Если в класс TestCase включается метод setUp(),
# Python выполняет метод setUp() перед запуском каждого метода, имя которого на-
# чинается с test_. Все объекты, созданные методом setUp(), становятся доступными
# во всех написанных вами тестовых методах.
# Используем setUp() для создания экземпляра AnonymousSurvey и набора ответов,
# которые могут использоваться в test_store_single_response() и test_store_
# three_responses():

# import unittest
# from language_survey import AnonymousSurvey
#
#
# class TestAnonymousSurvey(unittest.TestCase):
#     """Тесты для класса AnonymousSurvey"""
#
#     def setUp(self):
#         """Создание опроса и набора ответов для всех тестовых методов."""
#         question = "На каком языке вы впервые научились говорить?"
#         self.my_survey = AnonymousSurvey(question)   # 1
#         self.responses = ['English', 'Spanish', 'Mandarin']   # 2
#
#     def test_store_single(self):
#         """Проверяет что один ответ сохранён правильно"""
#         self.my_survey.store_response(self.responses[0])
#         self.assertIn(self.responses[0], self.my_survey.responses)
#
#     def test_store_three_responses(self):
#         """Проверяет, что три ответа были сохранены правильно."""
#         for response in self.responses:
#             self.my_survey.store_response(response)
#         for response in self.responses:
#             self.assertIn(response, self.my_survey.responses)
#
#
# if __name__ == '__main__':
#     unittest.main()

# Метод setUp() решает две задачи: он создает экземпляр опроса  и список отве-
# тов . Каждый из этих атрибутов снабжается префиксом self, поэтому он может
# использоваться где угодно в классе. Это обстоятельство упрощает два тестовых
# метода, потому что им уже не нужно создавать экземпляр опроса или ответы.
# Метод test_store_single_response() убеждается в том, что первый ответ в self.
# responses — self.responses[0] — сохранен правильно, а метод test_store_single_
# response() убеждается в том, что правильно были сохранены все три ответа в self.
# responses.
# При повторном запуске test_survey.py оба теста по-прежнему проходят. Эти тесты
# будут особенно полезными при расширении AnonymousSurvey с поддержкой не-
# скольких ответов для каждого участника. После внесения изменений вы можете
# повторить тесты и убедиться в том, что изменения не повлияли на возможность
# сохранения отдельного ответа или серии ответов.
# При тестировании классов, написанных вами, метод setUp() упрощает написание
# тестовых методов. Вы создаете один набор экземпляров и атрибутов в setUp(),
# а затем используете эти экземпляры во всех тестовых методах. Это намного проще
# и удобнее, чем создавать новый набор экземпляров и атрибутов в каждом тестовом
# методе.

# ПРИМЕЧАНИЕ
# Во время работы тестового сценария Python выводит один символ для каждого модульного теста
# после его завершения. Для прошедшего теста выводится точка; если при выполнении произошла
# ошибка, выводится символ E, а если не прошла проверка условия assert, выводится символ F. Вот
# почему вы увидите другое количество точек и символов в первой строке вывода при выполнении
# ваших тестовых сценариев. Если выполнение тестового сценария занимает слишком много време-
# ни, потому что сценарий содержит слишком много тестов, эти символы дадут некоторое представ-
# ление о количестве прошедших тестов.

# -------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 11-3. Работник: напишите класс Employee, представляющий работника. Метод __init__()
# должен получать имя, фамилию и ежегодный оклад; все эти значения должны сохраняться
# в атрибутах. Напишите метод give_raise(), который по умолчанию увеличивает ежегодный
# оклад на $5000 — но при этом может получать другую величину прибавки.
# Напишите тестовый сценарий для Employee. Напишите два тестовых метода, test_give_
# default_raise() и test_give_custom_raise(). Используйте метод setUp(), чтобы вам не при-
# ходилось заново создавать экземпляр Employee в каждом тестовом методе. Запустите свой
# тестовый сценарий и убедитесь в том, что оба теста прошли успешно.

# стр. 222

class Employee():
    """Описание работаника"""

    income = []

    def __init__(self, first_name, last_name, annual_salary):
        """Иниуиализация атрибутов работника."""
        self.first_name = first_name
        self.last_name = last_name
        self.annual_salary = annual_salary

    def give_raise(self):
        """Увеличение ежигодного оклада."""
        print("Для выхода из опроса введите 'q'")
        print(str(self.annual_salary) + " изначальный доход")
        while True:
            raise_01 = input("\nВведите годовой доход: ")
            if raise_01 == 'q':
                break
            self.annual_salary += int(raise_01)
            print("смотрим на увеличение дохода работает ли: " + str(self.annual_salary))

    def save_income(self):
        """Сохранить доход"""
        self.income.append(str(self.annual_salary))
        print("\nсмотрим сохранился ли доход " + str(self.income))


annual_income = Employee("Volodia", "Rahmanov", 5000)
# print("Узнаем имя и фамилию: " + str(annual_income))  # пишет не на человеческом....
# <__main__.Employee object at 0x016C2460>
annual_income.give_raise()
annual_income.save_income()
