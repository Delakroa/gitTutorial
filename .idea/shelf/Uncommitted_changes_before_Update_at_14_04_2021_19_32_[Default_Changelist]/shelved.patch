Index: faili_i_iskluchenia_chapter10.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Файлы и исключения\r\n\r\n# Чтение из файла\r\n\r\n# Гигантские объемы данных доступны в текстовых файлах. В них могут храниться\r\n# погодные данные, социально-экономическая информация, литературные произ-\r\n# ведения и многое другое. Чтение из файла особенно актуально для приложений,\r\n# предназначенных для анализа данных, но оно также может пригодиться в любой\r\n# ситуации, требующей анализа или изменения информации, хранящейся в фай-\r\n# ле. Например, программа может читать содержимое текстового файла и пере-\r\n# писывать его с форматированием, рассчитанным на отображение информации\r\n# в браузере.\r\n# Работа с информацией в текстовом файле начинается с чтения данных в память.\r\n# Вы можете прочитать все содержимое файла или же читать данные по строкам.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Чтение всего файла\r\n\r\n# Для начала нам понадобится файл с несколькими строками текста. Пусть это будет\r\n# файл с числом «пи» с точностью до 30 знаков, по 10 знаков на строку:\r\n\r\n# 3.1415926535\r\n# 8979323846\r\n# 2643383279\r\n\r\n# Чтобы опробовать эти примеры, либо введите данные в редакторе и сохраните файл\r\n# с именем pi_digits.txt, либо загрузите файл из ресурсов книги на странице https://\r\n# www.nostarch.com/pythoncrashcourse/. Сохраните файл в каталоге, в котором будут\r\n# храниться программы этой главы.\r\n# Следующая программа открывает этот файл, читает его и выводит содержимое\r\n# на экран:\r\n\r\n# with open('D:\\Python library\\pi_digits.txt') as file_object:\r\n#     contents = file_object.read()\r\n#     print(contents)\r\n\r\n\r\n# В первой строке этой программы многое заслуживает вашего внимания. Начнем\r\n# с функции open(). Чтобы выполнить любые операции с файлом — даже просто\r\n# вывести его содержимое, — сначала необходимо открыть файл. Функция open()\r\n# получает один аргумент: имя открываемого файла. Python ищет файл с указанным\r\n# именем в каталоге, в котором находится файл текущей программы. В данном при-\r\n# мере выполняется программа file_reader.py, поэтому Python ищет файл pi_digits.txt\r\n# в каталоге, в котором хранится file_reader.py. Функция open() возвращает объект,\r\n# представляющий файл. В данном случае open('pi_digits.txt') возвращает объ-\r\n# ект, представляющий файл pi_digits.txt. Python сохраняет этот объект в переменной\r\n# file_object, с которой мы будем работать позднее в программе.\r\n# Конструкция с ключевым словом with закрывает файл после того, как надобность\r\n# в нем отпадет. Обратите внимание: в этой программе есть вызов open(), но нет\r\n# вызова close(). Файлы можно открывать и закрывать явными вызовами open()\r\n# и close(); но если из-за ошибки в программе команда close() останется невыпол-\r\n# ненной, то файл не будет закрыт. На первый взгляд это не страшно, но некоррект-\r\n# ное закрытие файлов может привести к потере или порче данных. А если функция\r\n# close() будет вызвана слишком рано, программа попытается работать с закрытым\r\n# (то есть недоступным) файлом, что приведет к новым ошибкам. Не всегда можно\r\n# заранее определить, когда нужно закрывать файл, но с приведенной конструкцией\r\n# Python сделает это за вас. Вам остается лишь открыть файл и работать с ним так,\r\n# как требуется, надеясь на то, что Python закроет его автоматически в правильный\r\n# момент.\r\n# После того как в программе появится объект, представляющий файл pi_digits.txt, во\r\n# второй строке программы используется метод read(), который читает все содер-\r\n# жимое файла и сохраняет его содержимое в одной длинной строке в переменной\r\n# contents. При выводе значения contents на экране появляется все содержимое\r\n# файла :\r\n\r\n# 3.1415926535\r\n# 8979323846\r\n# 2643383279\r\n\r\n# Единственное различие между выводом и исходным файлом — лишняя пустая\r\n# строка в конце вывода. Откуда она взялась? Метод read() возвращает ее при чте-\r\n# нии, если достигнут конец файла. Если вы хотите удалить лишнюю пустую строку,\r\n# включите вызов rstrip() в команду print:\r\n\r\n# with open('D:\\Python library\\pi_digits.txt') as file_object:\r\n#     contents = file_object.read()\r\n#     print(contents.rstrip())\r\n\r\n# Напомним, что метод rstrip() удаляет все пропуски в конце строки. Теперь вывод\r\n# точно соответствует содержимому исходного файла:\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Пути к файлам\r\n\r\n# Если передать функции open() простое имя файла, такое как pi_digits.txt, Python\r\n# ищет файл в том каталоге, в котором находится файл, выполняемый в настоящий\r\n# момент (то есть файл программы .py).\r\n# В некоторых случаях (в зависимости от того, как организованы ваши рабочие фай-\r\n# лы) открываемый файл может и не находиться в одном каталоге с файлом програм-\r\n# мы. Например, файл программы может находиться в каталоге python_work; в ката-\r\n# логе python_work создается другой каталог с именем text_files для текстовых файлов,\r\n# с которыми работает программа. И хотя папка text_files находится в python_work,\r\n# простая передача open() имени файла из text_files не подойдет, потому что Python\r\n# проведет поиск файла в python_work и на этом остановится; поиск не будет продол-\r\n# жен во вложенном каталоге text_files. Чтобы открыть файлы из каталога, отличного\r\n# от того, в котором хранится файл программы, необходимо указать путь — то есть\r\n# приказать Python искать файлы в конкретном месте файловой системы.\r\n# Так как каталог text_files находится в python_work, для открытия файла из text_files\r\n# можно воспользоваться относительным путем. Относительный путь приказы-\r\n# вает Python искать файлы в каталоге, который задается относительно каталога,\r\n# в котором находится текущий файл программы. В системе Linux и OS X это вы-\r\n# глядит так:\r\n# with open('text_files/имя_файла.txt') as file_object:\r\n# Эта строка означает, что файл .txt следует искать в каталоге text_files; она предпо-\r\n# лагает, что каталог text_files находится в python_work (так оно и есть). В системах\r\n# Windows в путях к файлам вместо слеша (/) используется обратный слеш (\\):\r\n# with open('text_files\\имя_файла.txt') as file_object:\r\n# 188 Глава 10 • Файлы и исключения\r\n# Также можно точно определить местонахождение файла в вашей системе неза-\r\n# висимо от того, где хранится выполняемая программа. Такие пути называются\r\n# абсолютными и используются в том случае, если относительный путь не работает.\r\n# Например, если каталог text_files находится не в python_work, а в другом каталоге\r\n# (скажем, в каталоге с именем other_files), то передать open() путь 'text_files/\r\n# filename.txt' не получится, потому что Python будет искать указанный каталог\r\n# только внутри python_work. Чтобы объяснить Python, где следует искать файл, не-\r\n# обходимо записать полный путь.\r\n# Абсолютные пути обычно длиннее относительных, поэтому их лучше сохранять\r\n# в переменных, которые затем передаются open(). В Linux и OS X абсолютные пути\r\n# выглядят так:\r\n# file_path = '/home/ehmatthes/other_files/text_files/имя_файла.txt'\r\n# with open(file_path) as file_object:\r\n# В Windows они выглядят так:\r\n# file_path = 'C:\\Users\\ehmatthes\\other_files\\text_files\\имя_файла.txt'\r\n# with open(file_path) as file_object:\r\n# С абсолютными путями вы сможете читать файлы из любого каталога вашей си-\r\n# стемы. Пока будет проще хранить файлы в одном каталоге с файлами программ\r\n# или в каталогах, вложенных в каталог с файлами программ (таких как text_files из\r\n# рассмотренного примера).\r\n# ПРИМЕЧАНИЕ\r\n# Иногда в системах семейства Windows слеш в пути к файлам интерпретируется правильно. Если вы\r\n# используете Windows, но не получаете ожидаемых результатов, попробуйте использовать символы\r\n# обратного слеша.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Чтение по строкам\r\n\r\n# file_name = ('D:\\Python library\\pi_digits.txt')  # 1\r\n#\r\n# with open(file_name) as file_object:    # 2\r\n#     for line in file_object:   # 3\r\n#         print(line)\r\n\r\n\r\n# В точке \uF08C имя файла, из которого читается информация, сохраняется в перемен-\r\n# ной filename. Это стандартный прием при работе с файлами: так как переменная\r\n# filename не представляет конкретный файл (это всего лишь строка, которая со-\r\n# общает Python, где найти файл), вы сможете легко заменить 'pi_digits.txt'\r\n# именем другого файла, с которым вы собираетесь работать. После вызова open()\r\n# объект, представляющий файл и его содержимое, сохраняется в переменной\r\n# file_object \uF08D. Мы снова используем синтаксис with, чтобы поручить Python\r\n# открывать и закрывать файл в нужный момент. Для просмотра содержимого все\r\n# строки файла перебираются в цикле for по объекту файла \uF08E.\r\n# На этот раз пустых строк оказывается еще больше:\r\n\r\n# 3.1415926535\r\n#\r\n# 8979323846\r\n#\r\n# 2643383279\r\n\r\n\r\n# Пустые строки появляются из-за того, что каждая строка в текстовом файле за-\r\n# вершается невидимым символом новой строки. Команда print добавляет свой\r\n# символ новой строки при каждом вызове, поэтому в результате каждая строка\r\n# завершается двумя символами новой строки: один прочитан из файла, а другой\r\n# добавлен командой print. Вызов rstrip() в команде print удаляет лишние пу-\r\n# стые строки:\r\n\r\n\r\n# file_name = ('D:\\Python library\\pi_digits.txt')\r\n#\r\n# with open(file_name) as file_object:\r\n#     for line in file_object:\r\n#         print(line.rstrip())\r\n\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# Создание списка строк по содержимому файла\r\n\r\n# file_name = ('D:\\Python library\\pi_digits.txt')\r\n#\r\n# with open(file_name) as file_object:\r\n#     lines = file_object.readline()   # 1\r\n#     for line in lines:         # 2\r\n#         print(line.rstrip())\r\n\r\n# В точке \uF08C метод readlines() последовательно читает каждую строку из файла\r\n# и сохраняет ее в списке. Список сохраняется в переменной lines, с которой можно\r\n# продолжить работу после завершения блока with. В точке \uF08D в простом цикле for\r\n# выводятся все элементы списка lines. Так как каждый элемент lines соответствует\r\n# ровно одной строке файла, вывод точно соответствует его содержимому.\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# Работа с содержимым файла\r\n\r\n# filename = ('D:\\Python library\\pi_digits.txt')\r\n#\r\n# with open(filename) as file_object:\r\n#     lines = file_object.readlines()\r\n#\r\n#     pi_string = ''  # 1\r\n#     for line in lines:  # 2\r\n#         pi_string += line.rstrip()\r\n#\r\n#     print(pi_string)  # 3\r\n#     print(len(pi_string))\r\n\r\n# Сначала программа открывает файл и сохраняет каждую строку цифр в списке —\r\n# точно так же, как это делалось в предыдущем примере. В точке \uF08C создается пере-\r\n# менная pi_string для хранения цифр числа «пи». Далее следует цикл, который\r\n# добавляет к pi_string каждую серию цифр, из которой удаляется символ новой\r\n# строки \uF08D. В точке \uF08E программа выводит строку и ее длину:\r\n\r\n# Переменная pi_string содержит пропуски, которые присутствовали в начале\r\n# каждой строки цифр. Чтобы удалить их, достаточно использовать strip() вместо\r\n# rstrip():\r\n\r\n# В итоге мы получаем строку, содержащую значение «пи» с точностью до 30 знаков.\r\n# Длина строки равна 32 символам, потому что в нее также включается начальная\r\n# цифра 3 и точка:\r\n# 3.141592653589793238462643383279\r\n# 32\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Большие файлы: миллион цифр\r\n\r\n# filename = ('D:\\Python library\\pi_million_digits.txt')\r\n#\r\n# with open(filename) as file_object:\r\n#     lines = file_object.readlines()\r\n#\r\n#     pi_string = ''  # 1\r\n#     for line in lines:  # 2\r\n#         pi_string += line.rstrip()\r\n#\r\n#     print(pi_string[:52] + '...')  # 3\r\n#     print(len(pi_string))\r\n\r\n# -------------------------------------------------------------------------------------------------------------------\r\n\r\n# Проверка дня рождения\r\n\r\n# Меня всегда интересовало, не встречается ли мой день рождения среди цифр числа\r\n# «пи»? Воспользуемся только что созданной программой для проверки того, входит\r\n# ли запись дня рождения пользователя в первый миллион цифр. Для этого можно\r\n# записать день рождения в виде строки из цифр и посмотреть, присутствует ли эта\r\n# строка в pi_string:\r\n\r\n# filename = ('D:\\Python library\\pi_million_digits.txt')\r\n\r\n# with open(filename) as file_object:\r\n#     lines = file_object.readlines()\r\n#\r\n#     pi_string = \"\"\r\n#     for line in lines:\r\n#         pi_string += line.rstrip()\r\n#\r\n# birthday = input(\"Введите свой день рождения в форму ddmmyy:\")\r\n# if birthday in pi_string:\r\n#     print(\"Ваш день рождения отображается в первом миллионе цифр числа Пи.\")\r\n# else:\r\n#     print(\"Ваш день рождения не появляется в первом миллионе цифр числа Пи.\")\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-1. Изучение Python: откройте пустой файл в текстовом редакторе и напишите несколько\r\n# строк текста о возможностях Python. Каждая строка должна начинаться с фразы: «In Python\r\n# you can…» Сохраните файл под именем learning_python.txt в каталоге, использованном для\r\n# примеров этой главы. Напишите программу, которая читает файл и выводит текст три раза:\r\n# с чтением всего файла, с перебором строк объекта файла и с сохранением строк в списке\r\n# с последующим выводом списка вне блока with.\r\n\r\n# file = (\"D:\\Python library\\learning_python.txt\")\r\n#\r\n# print(\"--- Чтение всего файла:\")\r\n# with open(file) as file_object:\r\n#     text = file_object.read()\r\n#     print(text.rstrip())\r\n#\r\n# print(\"\\n--- Сохранение строк в списке:\")\r\n# with open(file) as file_object:\r\n#     lines = file_object.readlines()\r\n#     for line in lines:\r\n#         print(file.rstrip())\r\n\r\n# print(\"\\n--- Цикл по линиям:\")\r\n# with open(file) as file_object:\r\n#     for file in file_object:\r\n#         print(file.rstrip())\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-2. Изучение C: метод replace() может использоваться для замены любого слова в строке\r\n# другим словом. В следующем примере слово ‘dog’ заменяется словом ‘cat’:\r\n# >>> message = \"I really like dogs.\"\r\n# >>> message.replace('dog', 'cat')\r\n# 'I really like cats.'\r\n# Прочитайте каждую строку из только что созданного файла learning_python.txt и замените\r\n# слово Python названием другого языка, например C. Выведите каждую измененную строку\r\n# на экран.\r\n\r\n# file = (\"E:\\python library\\learning_python.txt\")\r\n#\r\n# with open(file) as file_object:\r\n#     files = file_object.readlines()\r\n#     for file in files:\r\n#         print(file.replace(\"Python\", \"C\").rstrip())\r\n\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Запись в файл\r\n\r\n# Один из простейших способов сохранения данных — запись в файл. Текст,\r\n# записанный в файл, останется доступным и после закрытия терминала с выводом вашей программы.\r\n# Вы сможете проанализировать результаты после\r\n# завершения программы или передать свои файлы другим. Вы также сможете\r\n# написать программы, которые снова читают сохраненный текст в память и работают с ним.\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# Запись в пустой файл\r\n\r\n# Чтобы записать текст в файл, необходимо вызвать open() со вторым аргументом,\r\n# который сообщает Python, что вы собираетесь записывать данные в файл. Чтобы\r\n# увидеть, как это делается, напишем простое сообщение и сохраним его в файле\r\n# (вместо того чтобы просто вывести на экран):\r\n\r\n# filename = (\"D:\\Python library\\learning_python.txt\")\r\n\r\n# with open(filename, \"w\") as file_object:       # 1\r\n#     file_object.write(\"I love programming.\")   # 2\r\n\r\n# При вызове open() в этом примере передаются два аргумента \uF08C. Первый аргумент,\r\n# как и прежде, содержит имя открываемого файла. Второй аргумент 'w' сообщает\r\n# Python, что файл должен быть открыт в режиме записи. Файлы можно открывать\r\n# в режиме чтения ('r'), записи ('w'), присоединения ('a') или в режиме, допуска-\r\n# ющем как чтение, так и запись в файл ('r+'). Если аргумент режима не указан,\r\n# Python по умолчанию открывает файл в режиме только для чтения.\r\n# Если файл, открываемый для записи, еще не существует, функция open() автома-\r\n# тически создает его. Будьте внимательны, открывая файл в режиме записи ('w'):\r\n# если файл существует, то Python уничтожит его данные перед возвращением\r\n# объекта файла.\r\n# В точке \uF08D метод write() используется с объектом файла для записи строки в файл.\r\n# Программа не выводит данные на терминал, но, открыв файл programming.txt, вы\r\n# увидите в нем одну строку:\r\n\r\n# I love programming.\r\n\r\n# ПРИМЕЧАНИЕ\r\n# Python может записывать в текстовые файлы только строковые данные. Если вы захотите сохра-\r\n# нить в текстовом файле числовую информацию, данные придется предварительно преобразовать\r\n# в строки функцией str().\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Многострочная запись\r\n\r\n# Функция write() не добавляет символы новой строки в записываемый текст. А это\r\n# означает, что если вы записываете сразу несколько строк без включения символов\r\n# новой строки, полученный файл может выглядеть не так, как вы рассчитывали:\r\n\r\n# filename = (\"D:\\Python library\\learning_python.txt\")\r\n#\r\n# with open(filename, \"w\") as file_object:\r\n#     file_object.write(\"I love programming.\")\r\n#     file_object.write(\"I love creating new games.\")\r\n\r\n# Открыв файл , вы увидите, что две строки «склеились»:\r\n# I love programming.I love creating new games.\r\n# Если включить символы новой строки в команды write(), текст будет состоять\r\n# из двух строк:\r\n\r\n\r\n# filename = (\"D:\\Python library\\learning_python.txt\")\r\n#\r\n# with open(filename, 'w') as file_object:\r\n#     file_object.write(\"I love programming.\\n\")\r\n#     file_object.write(\"I love creating new games.\\n\")\r\n\r\n\r\n# Результат выглядит так:\r\n# I love programming.\r\n# I love creating new games.\r\n# Для форматирования вывода также можно использовать пробелы, символы табу-\r\n# ляции и пустые строки по аналогии с тем, как это делалось с выводом на терминал.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Присоединение данных к файлу\r\n\r\n# filename = (\"D:\\Python library\\learning_python.txt\")\r\n#\r\n# with open (filename, \"a\") as file_object:    # 1\r\n#     file_object.write(\"I also love finding meaning in large datasets.\\n\")    # 2\r\n#     file_object.write(\"I love creating apps that can run in a browser.\\n\")\r\n\r\n# В точке \uF08C аргумент 'a' используется для открытия файла в режиме присоединения\r\n# (вместо перезаписи существующего файла). В точке \uF08D записываются две новые\r\n# строки, которые добавляются к содержимому\r\n\r\n\r\n# I love programming.\r\n# I love creating new games.\r\n# I also love finding meaning in large datasets.\r\n# I love creating apps that can run in a browser.\r\n\r\n# В результате к исходному содержимому файла добавляется новый текст.\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# УПРАЖНЕНИЯ\r\n# 10-3. Гость: напишите программу, которая запрашивает у пользователя его имя. Введенный\r\n# ответ сохраняется в файле с именем guest.txt.\r\n\r\n\r\n# names = input(\"What is you name?\\t\")\r\n# filename = (\"D:\\Python library\\he_task.txt\")\r\n#\r\n# with open(filename, \"w\") as file_object:\r\n#     file_object.write(names)\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-4. Гостевая книга: напишите цикл while, который в цикле запрашивает у пользователей\r\n# имена. При вводе каждого имени выведите на экран приветствие и добавьте строку с со-\r\n# общением в файл с именем guest_book.txt. Проследите за тем, чтобы каждое сообщение\r\n# размещалось в отдельной строке файла.\r\n\r\n\r\n# filename = (\"D:\\Python library\\he_task.txt\")\r\n#\r\n# print(\"Когда закончите введите quit\")\r\n#\r\n# while True:\r\n#     name = input(\"Введите своё имя: \")\r\n#     if name == \"quit\":\r\n#         break\r\n#     else:\r\n#         with open(filename, \"a\") as f:\r\n#             f.write(name + \"\\n\")\r\n#         print(\"Првиет \" + name + \" ,вы добавлены в гостевую книгу.\")\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-5. Опрос: напишите цикл while, в котором программа спрашивает у пользователя, по-\r\n# чему ему нравится программировать. Каждый раз, когда пользователь вводит очередную\r\n# причину, сохраните текст его ответа в файле.\r\n\r\n\r\n# filename = (\"D:\\Python library\\he_task.txt\")\r\n#\r\n#\r\n# book_names = []\r\n# while True:\r\n#     names = input(\"\\nПочему тебе нравится программирование:\\t\")\r\n#     book_names.append(names + \"\\n\")\r\n#\r\n#     continue_poll = input(\"Вы бы хотели, чтобы кто-то другой ответил?? (y/n) \")\r\n#     if continue_poll == \"y\":\r\n#         break\r\n#\r\n#     with open(filename, \"a\") as f:\r\n#         f.write(names + \"\\n\")\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Исключения\r\n# Для управления ошибками, возникающими в ходе выполнения программы,\r\n# в Python используются специальные объекты, называемые исключениями. Если\r\n# при возникновении ошибки Python не знает, что делать дальше, создается объект\r\n# исключения. Если в программу включен код обработки исключения, то выполне-\r\n# ние программы продолжится, а если нет — программа останавливается и выводит\r\n# трассировку с отчетом об исключении.\r\n# Исключения обрабатываются в блоках try-except. Блок try-except приказывает\r\n# Python выполнить некоторые действия, но при этом также сообщает, что нужно де-\r\n# лать при возникновении\r\n# исключения. С блоками try-except ваши программы будут\r\n# работать даже в том случае, если что-то пошло не так. Вместо невразумительной\r\n# трассировки выводится понятное сообщение об ошибке, которое вы определяете\r\n# в программе.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Обработка исключения ZeroDivisionError\r\n# Рассмотрим простую ошибку, при которой Python инициирует исключение. Ко-\r\n# нечно, вы знаете, что деление на ноль невозможно, но мы все же прикажем Python\r\n# выполнить эту операцию:\r\n# division.py\r\n\r\n# print(5/0)\r\n\r\n# Из этого ничего не выйдет, поэтому на экран выводятся данные трассировки:\r\n# Traceback (most recent call last):\r\n# File \"division.py\", line 1, in <module>\r\n# print(5/0)\r\n# \uF08C ZeroDivisionError: division by zero\r\n# Ошибка, упоминаемая в трассировке \uF08C — ZeroDivisionError, — является объектом\r\n# исключения. Такие объекты создаются в том случае, если Python не может выпол-\r\n# нить ваши распоряжения. Обычно в таких случаях Python прерывает выполнение\r\n# программы и сообщает тип обнаруженного исключения. Эта информация может\r\n# использоваться в программе; по сути вы сообщаете Python, как следует поступить\r\n# при возникновении исключения данного типа. В таком случае ваша программа\r\n# будет подготовлена к его появлению.\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# Блоки try-except\r\n# Если вы предполагаете, что в программе может произойти ошибка, напишите блок\r\n# try-except для обработки возникающего исключения. Такой блок приказывает\r\n# Python выполнить некоторый код, а также сообщает, что нужно делать, если при\r\n# его выполнении произойдет исключение конкретного типа.\r\n# Вот как выглядит блок try-except для обработки исключений ZeroDivisionError:\r\n\r\n# try:\r\n#     print(5/0)\r\n# except ZeroDivisionError:\r\n#     print(\"Вы не можете делить на ноль!\")\r\n\r\n# Команда print(5/0), порождающая ошибку, находится в блоке try. Если код в бло-\r\n# ке try выполнен успешно, то Python пропускает блок except. Если код в блоке\r\n# try порождает ошибку, то Python ищет блок except с соответствующей ошибкой\r\n# и выпускает код в этом блоке.\r\n# В этом примере код блока try порождает ошибку ZeroDivisionError, поэтому\r\n# Python ищет блок except с описанием того, как следует действовать в такой ситу-\r\n# ации. При выполнении кода этого блока пользователь видит понятное сообщение\r\n# об ошибке вместо данных трассировки:\r\n# You can't divide by zero!\r\n# Если бы за кодом try-except следовал другой код, то выполнение программы\r\n# продолжилось, потому что мы объяснили Python, как обрабатывать эту ошибку.\r\n# В следующем примере обработка ошибки позволяет программе продолжить вы-\r\n# полнение.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Использование исключений для предотвращения аварийного\r\n# завершения программы\r\n\r\n# Правильная обработка ошибок особенно важна в том случае, если программа\r\n# должна продолжить работу после возникновения ошибки. Такая ситуация часто\r\n# встречается в программах, запрашивающих данные у пользователя. Если програм-\r\n# ма правильно среагировала на некорректный ввод, она может запросить новые\r\n# данные после сбоя.\r\n# Создадим простой калькулятор, который выполняет только операцию деления:\r\n\r\n\r\n# print(\"Дай мне два числа, и я разделю их.\")\r\n# print(\"Введите 'q' чтобы выйти.\")\r\n# while True:\r\n#     first_number = input(\"\\nПервый номер: \")\r\n#     if first_number == 'q':\r\n#         break\r\n#     second_number = input(\"Второй номер: \")\r\n#     if second_number == 'q':\r\n#         break\r\n#     answer = int(first_number) / int(second_number)\r\n#     print(\"Ответ: \" + str(answer) + \"\\n\")\r\n\r\n# Программа запрашивает у пользователя первое число first_number \uF08C, а затем,\r\n# если пользователь не ввел q для завершения работы, запрашивает второе число\r\n# second_number \uF08D. Далее одно число делится на другое для получения результата\r\n# answer \uF08E. Программа никак не обрабатывает ошибки, так что попытка деления на\r\n# ноль приводит к ее аварийному завершению:\r\n\r\n# Конечно, аварийное завершение — это плохо, но еще хуже, если пользователь\r\n# увидит данные трассировки. Неопытного пользователя они собьют с толку, а при\r\n# сознательной попытке взлома злоумышленник сможет получить из них больше\r\n# информации, чем вам хотелось бы. Например, он узнает имя файла программы\r\n# и увидит некорректно работающую часть кода. На основании этой информации\r\n# опытный хакер иногда может определить, какие атаки следует применять против\r\n# вашего кода.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Блок else\r\n\r\n# Для повышения устойчивости программы к ошибкам можно заключить строку,\r\n# выдающую ошибки, в блок try-except. Ошибка происходит в строке, выполняющей\r\n# деление; следовательно, именно эту строку следует заключить в блок try-except.\r\n# Данный пример также включает блок else. Любой код, зависящий от успешного\r\n# выполнения блока try, размещается в блоке else:\r\n\r\n\r\n# print(\"Give me two numbers, and I'll divide them.\")\r\n# print(\"Enter 'q' to quit.\")\r\n# while True:\r\n#     first_number = input(\"\\nПервый номер: \")\r\n#     if first_number == 'q':\r\n#         break\r\n#     second_number = input(\"Второй номер: \")\r\n#     try:    # 1\r\n#         answer = int(first_number) / int(second_number)\r\n#     except ZeroDivisionError:    # 2\r\n#         print(\"Вы не можете разделить на 0!\")\r\n#     else:   # 3\r\n#         print(answer)\r\n\r\n# Программа пытается выполнить операцию деления в блоке try \uF08C, который\r\n# включает только код, способный породить ошибку. Любой код, зависящий\r\n# от успешного выполнения блока try, добавляется в блок else. В данном случае,\r\n# если операция деления выполняется успешно, блок else используется для вы-\r\n# вода результата \uF08D.\r\n# Блок except сообщает Python, как следует поступать при возникновении ошибки\r\n# ZeroDivisionError \uF08E. Если при выполнении команды из блока try происходит\r\n# ошибка, связанная с делением на 0, программа выводит понятное сообщение,\r\n# которое объясняет пользователю, как избежать подобных ошибок. Выполнение\r\n# программы продолжается, и пользователь не сталкивается с трассировкой:\r\n\r\n# Блок try-except-else работает так: Python пытается выполнить код в блоке try.\r\n# В блоках try следует размещать только тот код, при выполнении которого может\r\n# возникнуть исключение. Иногда некоторый код должен выполняться только в том\r\n# случае, если выполнение try прошло успешно; такой код размещается в блоке else.\r\n# Блок except сообщает Python, что делать, если при выполнении кода try произо-\r\n# шло определенное исключение. Заранее определяя вероятные источники ошибок,\r\n# вы повышаете надежность своих программ, которые продолжают работать даже при\r\n# вводе некорректных данных или при недоступности ресурсов. Ваш код оказывается\r\n# защищенным от случайных ошибок пользователей и сознательных атак.\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# Обработка исключения FileNotFoundError\r\n\r\n# Одна из стандартных проблем при работе с файлами — отсутствие необходимых\r\n# файлов. Тот файл, который вам нужен, может находиться в другом месте, в имени\r\n# файла может быть допущена ошибка, или файл может вообще не существовать.\r\n# Все эти ситуации достаточно прямолинейно обрабатываются в блоках try-except.\r\n# Попробуем прочитать данные из несуществующего файла. Следующая програм-\r\n# ма пытается прочитать содержимое файла с текстом «Алисы в Стране чудес», но\r\n# я не сохранил файл alice.txt в одном каталоге с файлом alice.py:\r\n\r\n\r\n# Прочитать данные из несуществующего файла нельзя, поэтому Python выдает\r\n# исключение:\r\n\r\n# filename = (\"alice.txt\")\r\n# try:\r\n#     with open(filename) as f_obj:\r\n#         contents = f_obj.read()\r\n# except FileNotFoundError:\r\n#     msg = (\"Извините, файл \" + filename + \" не существует.\")\r\n#     print(msg)\r\n\r\n\r\n# В последней строке трассировки упоминается FileNotFoundError: это исключение\r\n# выдается в том случае, если Python не может найти открываемый файл. В данном\r\n# примере функция open() порождает ошибку, и, чтобы обработать ее, блок try на-\r\n# чинается перед строкой с вызовом open():\r\n\r\n\r\n# В этом примере код блока try выдает исключение FileNotFoundError, поэто-\r\n# му Python ищет блок except для этой ошибки. Затем выполняется код этого\r\n# блока, в результате чего вместо трассировки выдается доступное сообщение\r\n# об ошибке:\r\n\r\n# Sorry, the file alice.txt does not exist.\r\n\r\n# Если файл не существует, программе больше делать нечего, поэтому код обработ-\r\n# ки ошибок почти ничего не добавляет в эту программу. Доработаем этот пример\r\n# и посмотрим, как обработка исключений помогает при работе с несколькими\r\n# файлами.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Анализ текста\r\n\r\n# Программа может анализировать текстовые файлы, содержащие целые книги.\r\n# Многие классические произведения, ставшие общественным достоянием, доступны\r\n# в виде простых текстовых файлов. Тексты, использованные в этом разделе, взяты\r\n# с сайта проекта «Гутенберг» (http://gutenberg.org/). На этом сайте хранится под-\r\n# борка литературных произведений, не защищенных авторским правом; это превос-\r\n# ходный ресурс для разработчиков, которые собираются работать с литературными\r\n# текстами в своих программных проектах.\r\n# Прочитаем текст «Алисы в Стране чудес» и попробуем подсчитать количество слов\r\n# в тексте. Мы воспользуемся методом split(), предназначенным для построения\r\n# списка слов на основе строки. Вот как метод split() работает со строкой, содер-\r\n# жащей только название книги:\r\n\r\n# 199\r\n\r\n# >>> title = \"Alice in Wonderland\"\r\n# >>> title.split()\r\n# ['Alice', 'in', 'Wonderland']\r\n\r\n# Метод split() разделяет строку на части по всем позициям, в которых обнаружит\r\n# пробел, и сохраняет все части строки в элементах списка. В результате создается\r\n# список слов, входящих в строку (впрочем, вместе с некоторыми словами могут\r\n# храниться знаки препинания). Для подсчета слов в книге мы воспользуемся вызо-\r\n# вом split() для всего текста, а затем подсчитаем элементы списка, чтобы получить\r\n# примерное количество слов в тексте:\r\n\r\n# filename = (\"d:\\Python library\\Alice_in_Wonderland.txt\")\r\n# try:\r\n#     with open(filename) as f_obj:\r\n#         contents = f_obj.read()\r\n# except FileNotFoundError:\r\n#     msg = (\"Извините, файл \" + filename + \" не существует.\")\r\n#     print(msg)\r\n# else:\r\n#     # Подсчёт приблизительного количества строк в файле.\r\n#     words = contents.split()  # 1\r\n#     num_words = len(words)    # 2\r\n#     print(\"Файл \" + filename + \" имеет около \" + str(num_words) + \" строк.\")  # 3\r\n\r\n# был выполнен без ошибок. В точке \uF08C программа загружает текст в переменную\r\n# contents, которая теперь содержит весь текст в виде одной длинной строки и ис-\r\n# пользует метод split() для получения списка всех слов в книге. Запрашивая\r\n# длину этого списка при помощи функции len(), мы получаем неплохое при-\r\n# ближенное значение количества слов в исходной строке \uF08D. В точке \uF08E выводится\r\n# сообщение с количеством слов, найденных в файле. Этот код помещен в блок\r\n# else, потому что он должен выводиться только в случае успешного выполнения\r\n# блока try. Выходные данные программы сообщают, сколько слов содержит файл\r\n# alice.txt:\r\n# The file alice.txt has about 29461 words.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Работа с несколькими файлами\r\n\r\n# Добавим еще несколько файлов с книгами для анализа. Но для начала переместим\r\n# основной код программы в функцию с именем count_words(). Это упростит про-\r\n# ведение анализа для нескольких книг:\r\n\r\n\r\n# def count_words(filename):\r\n#     \"\"\"Подсчёт приблизительного количества строк в файле.\"\"\"\r\n#\r\n#     try:\r\n#         with open(filename) as f_obj:\r\n#             contents = f_obj.read()\r\n#     except FileNotFoundError:\r\n#         msg = (\"Извините, файл \" + filename + \" не существует.\")\r\n#         print(msg)\r\n#     else:\r\n#         # Подсчёт приблизительного количества строк в файле.\r\n#         words = contents.split()  # 1\r\n#         num_words = len(words)  # 2\r\n#         print(\"Файл \" + filename + \" имеет около \" + str(num_words) + \" строк.\")\r\n#\r\n#\r\n# filename = 'd:\\Python library\\Alice_in_Wonderland.txt'\r\n# count_words(filename)\r\n\r\n\r\n# Бульшая часть кода не изменилась. Мы просто снабдили код отступом и пере-\r\n# местили его в тело count_words(). Кроме того, комментарий был преобразован\r\n# в строку документации \uF08C.\r\n# Теперь мы можем написать простой цикл для подсчета слов в любом тексте,\r\n# который нужно проанализировать. Для этого имена анализируемых файлов со-\r\n# храняются в списке, после чего для каждого файла в списке вызывается функ-\r\n# ция count_words(). Мы попробуем подсчитать слова в «Алисе в Стране чудес»,\r\n# «Сиддхартхе», «Моби Дике» и «Маленьких женщинах» — все эти книги есть\r\n# в свободном доступе. Я намеренно не стал копировать файл siddhartha.txt в каталог\r\n# с программой word_count.py, чтобы выяснить, насколько хорошо наша программа\r\n# справляется с отсутствием файла:\r\n\r\n# def count_words(filename):\r\n#     \"\"\"Подсчёт приблизительного количества строк в файле.\"\"\"\r\n#\r\n#     try:\r\n#         with open(filename) as f_obj:\r\n#             contents = f_obj.read()\r\n#     except FileNotFoundError:\r\n#         msg = (\"Извините, файл \" + filename + \" не существует.\")\r\n#         print(msg)\r\n#     else:\r\n#         # Подсчёт приблизительного количества строк в файле.\r\n#         words = contents.split()  # 1\r\n#         num_words = len(words)  # 2\r\n#         print(\"Файл \" + filename + \" имеет около \" + str(num_words) + \" строк.\")\r\n#\r\n#\r\n# filenames = ['d:\\Python library\\Alice_in_Wonderland.txt',\r\n#              'siddhartha.txt',\r\n#              'moby_dick.txt',\r\n#              'little_women.txt']\r\n# for filename in filenames:\r\n#     count_words(filename)\r\n\r\n# Отсутствие файла  не влияет на выполнение программы:\r\n\r\n# Файл d:\\Python library\\Alice_in_Wonderland.txt имеет около 17842 строк.\r\n# Извините, файл siddhartha.txt не существует.\r\n# Извините, файл moby_dick.txt не существует.\r\n# Извините, файл little_women.txt не существует.\r\n# Использование блока try-except в этом примере дает два важных преимущества:\r\n# программа ограждает пользователя от вывода трассировки и продолжает выполне-\r\n# ние, анализируя тексты, которые ей удается найти. Если бы в программе не пере-\r\n# хватывалось исключение FileNotFoundError, инициированное из-за отсутствия\r\n# siddhartha.txt, то пользователь увидел бы полную трассировку, а работа программы\r\n# прервалась бы после попытки подсчитать слова в тексте «Сиддхартхи»; до анализа\r\n# «Моби Дика» или «Маленьких женщин» дело не дошло бы.\r\n\r\n# ----------------------------------------------------------------------------------------------------------------------\r\n\r\n# Ошибки без уведомления пользователя\r\n\r\n# В предыдущем примере мы сообщили пользователю о том, что один из файлов ока-\r\n# зался недоступен. Тем не менее вы не обязаны сообщать о каждом обнаруженном\r\n# исключении. Иногда при возникновении исключения программа должна просто\r\n# проигнорировать сбой и продолжать работу, словно ничего не произошло. Для\r\n# этого блок try пишется так же, как обычно, но в блоке except вы явно приказыва-\r\n# ете Python не предпринимать никаких особых действий в случае ошибки. В языке\r\n# Python существует команда pass, с которой блок ничего не делает:\r\n\r\n# def count_words(filename):\r\n#     \"\"\"Подсчёт приблизительного количества строк в файле.\"\"\"\r\n#\r\n#     try:\r\n#         with open(filename) as f_obj:\r\n#             contents = f_obj.read()\r\n#     except FileNotFoundError:\r\n#         pass  # 1\r\n#     else:\r\n#         # Подсчёт приблизительного количества строк в файле.\r\n#         words = contents.split()  # 1\r\n#         num_words = len(words)  # 2\r\n#         print(\"Файл \" + filename + \" имеет около \" + str(num_words) + \" строк.\")\r\n#\r\n#\r\n# filenames = ['d:\\Python library\\Alice_in_Wonderland.txt',\r\n#              'siddhartha.txt',\r\n#              'moby_dick.txt',\r\n#              'little_women.txt']\r\n# for filename in filenames:\r\n#     count_words(filename)\r\n\r\n# Единственное отличие этого листинга от предыдущего — команда pass в точке \uF08C.\r\n# Теперь при возникновении ошибки FileNotFoundError выполняется код в блоке\r\n# except, но при этом ничего не происходит. Программа не выдает данные трасси-\r\n# ровки и вообще никакие результаты, указывающие на возникновение ошибки.\r\n# Пользователи получают данные о количестве слов во всех существующих файлах,\r\n# однако ничто не сообщает о том, что какой-то файл не был найден:\r\n#\r\n#\r\n# Файл d:\\Python library\\Alice_in_Wonderland.txt имеет около 17842 строк.\r\n\r\n# Команда pass также может служить временным заполнителем. Она напоминает,\r\n# что в этот конкретный момент выполнения вашей программы вы решили ниче-\r\n# го не предпринимать, хотя, возможно, сделаете что-то позднее. Например, эта\r\n# программа может записать все имена отсутствующих файлов в файл с именем\r\n# missing_files.txt. Пользователи этот файл не увидят, но создатель программы сможет\r\n# прочитать его и разобраться с отсутствующими текстами.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# О каких ошибках нужно сообщать?\r\n\r\n# Как определить, в каком случае следует сообщить об ошибке пользователю, а когда\r\n# можно просто проигнорировать ее незаметно для пользователя? Если пользователь\r\n# знает, с какими текстами должна работать программа, вероятно, он предпочтет по-\r\n# лучить сообщение, объясняющее, почему некоторые тексты были пропущены при\r\n# анализе. Пользователь ожидает увидеть какие-то результаты, но не знает, какие\r\n# книги должны быть проанализированы? Возможно, ему и не нужно знать о недо-\r\n# ступности каких-то файлов. Лишняя информация только сделает вашу программу\r\n# менее удобной для пользователя. Средства обработки ошибок Python позволяют\r\n# достаточно точно управлять тем, какой объем информации следует предоставить\r\n# пользователю.\r\n# Хорошо написанный, правильно протестированный код редко содержит внутрен-\r\n# ние ошибки (например, синтаксические или логические). Но в любой ситуации,\r\n# в которой ваша программа зависит от внешних факторов (пользовательского ввода,\r\n# существования файла, доступности сетевого подключения), существует риск воз-\r\n# никновения исключения. С накоплением практического опыта вы начнете видеть,\r\n# в каких местах программы следует разместить блоки обработки исключений\r\n# и сколько информации предоставлять пользователям о возникающих ошибках.\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# УПРАЖНЕНИЯ\r\n# 10-6. Сложение: при вводе числовых данных часто встречается типичная проблема: поль-\r\n# зователь вводит текст вместо чисел. При попытке преобразовать данные в int происходит\r\n# исключение TypeError. Напишите программу, которая запрашивает два числа, складывает\r\n# их и выводит результат. Перехватите исключение TypeError, если какое-либо из входных\r\n# значений не является числом, и выведите удобное сообщение об ошибке. Протестируйте\r\n# свою программу: сначала введите два числа, а потом введите текст вместо одного из чисел.\r\n\r\n# try:\r\n#     a = input(\"Введите первое число: \")\r\n#     a = int(a)\r\n#     b = input(\"Введите второе число: \")\r\n#     b = int(b)\r\n# except ValueError:\r\n#     print(\"Введите число, а не букву или знак!\\n\")\r\n# else:\r\n#     sum = a + b\r\n#     print(\"сумма чисел \" + str(a) + \" + \" + str(b) + \" равняется \" + \" = \" + str(sum) + \"\\n\")\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-7. Калькулятор: заключите код из упражнения 10-6 в цикл while, чтобы пользователь\r\n# мог продолжать вводить числа, даже если он допустил ошибку и ввел текст вместо числа.\r\n\r\n\r\n# while True:\r\n#     print(\"Введите q для выхода из цикла\")\r\n#     try:\r\n#         a = input(\"Введите первое число: \")\r\n#         if a == \"q\":\r\n#             break\r\n#\r\n#         a = int(a)\r\n#\r\n#         b = input(\"Введите второе число: \")\r\n#         if b == \"q\":\r\n#             break\r\n#\r\n#         b = int(b)\r\n#\r\n#\r\n#     except ValueError:\r\n#         print(\"Введите число, а не букву или знак!\\n\")\r\n#     else:\r\n#         sum = a + b\r\n#         print(\"сумма чисел \" + str(a) + \" + \" + str(b) + \" равняется \" + \" = \" + str(sum) + \"\\n\")\r\n\r\n# стр 203\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-8. Кошки и собаки: создайте два файла с именами cats.txt и dogs.txt. Сохраните минимум\r\n# три клички кошек в первом файле и три клички собак во втором. Напишите программу,\r\n# которая пытается прочитать эти файлы и выводит их содержимое на экран. Заключите\r\n# свой код в блок try-except для перехвата исключения FileNotFoundError и вывода понятного\r\n# сообщения об отсутствии файла. Переместите один из файлов в другое место файловой\r\n# системы; убедитесь в том, что код блока except выполняется, как и положено.\r\n# try:\r\n#     with open(\"D:\\Python library\\cat.txt\") as files_object:\r\n#         cat = files_object.read()\r\n# except FileNotFoundError:\r\n#     print(\"\\nЭтого файла нет в данной директории\")\r\n#\r\n# else:\r\n#     print(cat.title())\r\n#\r\n# try:\r\n#     with open(\"D:\\Python library\\dog.txt\") as files_object:\r\n#         dog = files_object.read()\r\n# except FileNotFoundError:\r\n#         print(\"\\nФайла dog.txt нет в данной директории\")\r\n# else:\r\n#     print(dog.title())\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-9. Ошибки без уведомления: измените блок except из упражнения 10-8 так, чтобы при\r\n# отсутствии файла программа продолжала работу, не уведомляя пользователя о проблеме.\r\n\r\n# try:\r\n#     with open(\"D:\\Python library\\cat.txt\") as files_object:\r\n#         cat = files_object.read()\r\n# except FileNotFoundError:\r\n#     print(\"\\nЭтого файла нет в данной директории\")\r\n#\r\n# else:\r\n#     print(cat.title())\r\n#\r\n# try:\r\n#     with open(\"D:\\Python library\\dog.txt\") as files_object:\r\n#         dog = files_object.read()\r\n# except FileNotFoundError:\r\n#     pass\r\n# else:\r\n#     print(dog.title())\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# 10-10. Частые слова: зайдите на сайт проекта «Гутенберг» (http://gutenberg.org/) и найдите\r\n# несколько книг для анализа. Загрузите текстовые файлы этих произведений или скопируй-\r\n# те текст из браузера в текстовый файл на вашем компьютере.\r\n# Для подсчета количества вхождений слова или выражения в строку можно воспользовать-\r\n# ся методом count(). Например, следующий код подсчитывает количество вхождений ‘row’\r\n# в строке:\r\n\r\n# >>> line = \"Row, row, row your boat\"\r\n# >>> line.count('row')\r\n# 2\r\n# >>> line.lower().count('row')\r\n# 3\r\n# Обратите внимание: преобразование строки к нижнему регистру функцией lower() позволя-\r\n# ет найти все вхождения искомого слова независимо от регистра.\r\n# Напишите программу, которая читает файлы из проекта «Гутенберг» и определяет количе-\r\n# ство вхождений слова ‘the’ в каждом тексте.\r\n\r\n# try:\r\n#     with open(\"D:\\Python library\\The Joss A Reversion by Richard Marsh.txt\") as file_object:\r\n#         file = file_object.read().lower()\r\n# except UnicodeDecodeError:\r\n#     print(\"Неверная кодировка в файле\")\r\n# else:\r\n#     file_count = file.count(\"the\")\r\n#     print(\"Файл \" + \"The Joss A Reversion by Richard Marsh.txt\" + \" имеет около \" + str(file_count) + \" строк.\\n\")\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Сохранение данных\r\n\r\n# Многие ваши программы будут запрашивать у пользователя информацию. Напри-\r\n# мер, пользователь может вводить настройки для компьютерной игры или данные\r\n# для визуального представления. Чем бы ни занималась ваша программа, инфор-\r\n# мация, введенная пользователем, будет сохраняться в структурах данных (таких,\r\n# как списки или словари). Когда пользователь закрывает программу, введенную\r\n# им информацию почти всегда следует сохранять на будущее. Простейший способ\r\n# сохранения данных основан на использовании модуля json.\r\n# Модуль json обеспечивает запись простых структур данных Python в файл и за-\r\n# грузку данных из файла при следующем запуске программы. Модуль json также\r\n# может использоваться для обмена данными между программами Python. Более\r\n# того, формат данных JSON не привязан к Python, поэтому данные в этом формате\r\n# можно передавать программам, написанным на многих других языках програм-\r\n# мирования. Это полезный и универсальный формат, который к тому же легко\r\n# изучается.\r\n\r\n# ПРИМЕЧАНИЕ\r\n# Формат JSON (JavaScript Object Notation) был изначально разработан для JavaScript. Впрочем,\r\n# с того времени он стал использоваться во многих языках, включая Python.\r\n\r\n# --------------------------------------------------------------------------------------------------------------------\r\n\r\n# Функции json.dump() и json.load()\r\n\r\n# Напишем короткую программу для сохранения набора чисел и другую программу,\r\n# которая будет читать эти числа обратно в память. Первая программа использует\r\n# функцию json.dump(), а вторая — функцию json.load().\r\n# Функция json.dump() получает два аргумента: сохраняемые данные и объект фай-\r\n# ла, используемый для сохранения. В следующем примере json.dump() используется\r\n# для сохранения списка чисел:\r\n\r\n# import json\r\n#\r\n# numbers = [2, 3, 5, 7, 11, 13]\r\n#\r\n# filename = 'numbers.json'       # 1\r\n# with open(filename, \"w\") as f_obj:   # 2\r\n#     json.dump(numbers, f_obj)    # 3\r\n\r\n\r\n# Программа импортирует модуль json и создает список чисел для работы. В точке \uF08C\r\n# выбирается имя файла для хранения списка. Обычно для таких файлов принято\r\n# использовать\r\n# расширение .json, указывающее, что данные в файле хранятся в фор-\r\n# мате JSON. Затем файл открывается в режиме записи, чтобы модуль json мог запи-\r\n# сать в него данные \uF08D. В точке \uF08E функция json.dump() используется для сохранения\r\n# списка numbers в файле numbers.json.\r\n# Программа ничего не выводит, но давайте откроем файл numbers.json и посмотрим\r\n# на его содержимое. Данные хранятся в формате, очень похожем на код Python:\r\n# [2, 3, 5, 7, 11, 13]\r\n# А теперь напишем следующую программу, которая использует json.load()\r\n# для чтения\r\n# списка обратно в память:\r\n\r\n# filename = 'numbers.json'   # 1\r\n# with open(filename) as f_obj:   # 2\r\n#     numbers = json.load(f_obj)    # 3\r\n#\r\n# print(numbers)\r\n\r\n# В точке \uF08C для чтения данных используется тот же файл, в который эти данные\r\n# были записаны. На этот раз файл открывается в режиме чтения, потому что Python\r\n# нужно только прочитать данные из файла \uF08D. В точке \uF08E функция json.load() ис-\r\n# пользуется для загрузки информации из numbers.json; эта информация сохраняется\r\n# в переменной numbers.\r\n# Наконец, программа выводит прочитанный список. Как видите, этот тот же список,\r\n# который был создан в программе number_writer.py:\r\n# [2, 3, 5, 7, 11, 13]\r\n# Модуль json позволяет организовать простейший обмен данными между про-\r\n# граммами.\r\n\r\n# -------------------------------------------------------------------------------------------------------------------\r\n\r\n# Сохранение и чтение данных, сгенерированных пользователем\r\n\r\n# Сохранение с использованием модуля json особенно полезно при работе с данны-\r\n# ми, сгенерированными пользователем, потому что без сохранения эта информа-\r\n# ция будет потеряна при остановке программы. В следующем примере программа\r\n# запрашивает у пользователя имя при первом запуске программы и «вспоминает»\r\n# его при повторных запусках.\r\n# Начнем с сохранения имени пользователя:\r\n\r\n# import json\r\n# username = input(\"Скажите своё имя? \")   # 1\r\n#\r\n# filename = 'username.json'\r\n# with open(filename, \"w\") as f_obj:\r\n#     json.dump(username, f_obj)   # 2\r\n#     print(\"Мы будем помнить тебя, когда ты вернешься, \" + username +\r\n#           \"!\")   # 3\r\n\r\n\r\n# В точке \uF08C программа запрашивает имя пользователя для сохранения. Затем вы-\r\n# зывается функция json.dump(), которой передается имя пользователя и объект\r\n# файла; функция сохраняет имя пользователя в файле \uF08D. Далее выводится сообще-\r\n# ние о том, что имя пользователя было сохранено \uF08E:\r\n\r\n# What is your name? Eric\r\n# We'll remember you when you come back, Eric!\r\n\r\n# А теперь напишем другую программу, которая приветствует пользователя по ранее\r\n# сохраненному имени:\r\n\r\n# import json\r\n#\r\n# file_filename = 'username.json'\r\n#\r\n# with open(file_filename) as f_obj:\r\n#     username = json.load(f_obj)    # 1\r\n#     print(\"С возвращением, \" + username + \"!\")    # 2\r\n\r\n# В точке \uF08C вызов json.load() читает информацию из файла username.json в пере-\r\n# менную username. После того как данные будут успешно прочитаны, мы можем\r\n# поприветствовать пользователя по имени \uF08D:\r\n\r\n# Welcome back, Eric!\r\n\r\n# Теперь эти две программы необходимо объединить в один файл. Когда пользова-\r\n# тель запускает remember_me.py, программа должна взять имя пользователя из памя-\r\n# ти, если это возможно; соответственно, программа начинается с блока try, который\r\n# пытается прочитать имя пользователя. Если файл username.json не существует,\r\n# блок except запросит имя пользователя и сохранит его в username.json на будущее:\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# import json\r\n\r\n# Программа загружает имя пользователя, если оно было сохраннено ранее.\r\n# В противном случае она запрашивает имя пользователя и сохраняет его.\r\n\r\n# filename = 'username.json'\r\n# try:\r\n#     with open(filename) as f_obj:    # 1\r\n#         username = json.load(f_obj)   # 2\r\n# except FileNotFoundError:    # 3\r\n#     username = input(\"Скажите ваше имя? \")   # 4\r\n#     with open(filename, 'w') as f_obj:    # 5\r\n#         json.dump(username, f_obj)\r\n#         print(\"Запомним вас до следующего возвращения \" + username + \"!\")\r\n# else:\r\n#     print(\"С возвращением, \" + username + \"!\")\r\n#\r\n# Никакого нового кода здесь нет; просто блоки кода из двух предыдущих приме-\r\n# ров были объединены в один файл. В точке \uF08C программа пытается открыть файл\r\n# username.json. Если файл существует, программа читает имя пользователя в па-\r\n# мять \uF08D и выводит сообщение, приветствующее пользователя, в блоке else. Если\r\n# программа запускается впервые, то файл username.json не существует, и происходит\r\n# исключение FileNotFoundError \uF08E. Python переходит к блоку except, в котором\r\n# пользователю предлагается ввести имя \uF08F. Затем программа вызывает json.dump()\r\n# для сохранения имени пользователя и выводит приветствие \uF090.\r\n# Какой бы блок ни выполнялся, результатом является имя пользователя и соот-\r\n# ветствующее сообщение. При первом запуске программы результат выглядит\r\n# так:\r\n\r\n# What is your name? Eric\r\n# We'll remember you when you come back, Eric!\r\n# Если же программа уже была выполнена хотя бы один раз, результат будет таким:\r\n# Welcome back, Eric!\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# Рефакторинг\r\n\r\n# Часто возникает типичная ситуация: код работает, но вы понимаете, что его струк-\r\n# туру можно усовершенствовать, разбив его на функции, каждая из которых ре-\r\n# шает свою конкретную задачу. Этот процесс называется рефакторингом (или\r\n# переработкой). Рефакторинг делает ваш код более чистым, понятным и простым\r\n# в расширении.\r\n# В процессе рефакторинга remember_me.py мы можем переместить основную часть\r\n# логики в одну или несколько функций. Основной задачей remember_me.py является\r\n# вывод приветствия для пользователя, поэтому весь существующий код будет пере-\r\n# мещен в функцию greet_user():\r\n\r\n# import json\r\n\r\n\r\n# def greet_user():\r\n#     \"\"\"Приветствует пользователя по имени.\"\"\"   # 1\r\n\r\n\r\n# filename = \"username.json\"\r\n# try:\r\n#     with open(filename) as f_obj:\r\n#         username = json.load(f_obj)\r\n# except FileNotFoundError:\r\n#     username = input(\"Ваше имя? \")\r\n#     with open(filename, \"w\") as f_obj:\r\n#         json.dump(username, f_obj)\r\n#         print(\"Мы запомним вас до следующего возвращения, \" + username + \"!\")\r\n# else:\r\n#     print(\"С возвращением \" + username + \"!\")\r\n#\r\n# greet_user()\r\n\r\n\r\n# С переходом на функцию комментарии дополняются строкой документации, кото-\r\n# рая описывает работу кода в текущей версии \uF08C. Код становится немного чище, но\r\n# функция greet_user() не только приветствует пользователя — она также загружает\r\n# хранимое имя пользователя, если оно существует, и запрашивает новое имя, если\r\n# оно не было сохранено ранее.\r\n# Переработаем функцию greet_user(), чтобы она не решала столько разных задач.\r\n# Начнем с перемещения кода загрузки хранимого имени пользователя в отдельную\r\n# функцию:\r\n\r\n# 208 Глава 10 • Файлы и исключения\r\n\r\n# странный нерабочий пример\r\n\r\nimport json\r\n\r\n# def get_stored_username():\r\n#     \"\"\"Получает хранимое имя пользователя. если оно существует.\"\"\"\r\n\r\n\r\n# filename = \"username.json\"\r\n# try:\r\n#     with open(filename) as f_obj:\r\n#         username = json.load(f_obj)\r\n# except FileNotFoundError:\r\n#     pass\r\n# else:\r\n#     return username\r\n#\r\n#\r\n# def greet_user():\r\n#     \"\"\"Приветствие пользователя по имени\"\"\"\r\n#     username = get_stored_username()\r\n#     if username:\r\n#         print(\"С возвращением, \" + username + \"!\")\r\n#     else:\r\n#\r\n#\r\n# username = input(\"Ваше имя? \")\r\n# filename = 'username.json'\r\n# with open(filename, 'w') as f_obj:\r\n#     json.dump(username, f_obj)\r\n#     print(\"заопмнили вас до возвращения \" + username + \"!\")\r\n#\r\n# greet_user()\r\n\r\n# Новая функция get_stored_username() имеет четкое предназначение, изложенное\r\n# в строке документации \uF08C. Эта функция читает и возвращает сохраненное имя\r\n# пользователя, если его удается найти. Если файл username json не существует,\r\n# то функция возвращает None \uF08D. И это правильно: функция должна возвращать\r\n# либо ожидаемое значение, либо None. Это позволяет провести простую проверку\r\n# возвращаемого значения функции. В точке \uF08E программа выводит приветствие\r\n# для пользователя, если попытка получения имени пользователя была успешной;\r\n# в противном случае программа запрашивает новое имя пользователя.\r\n# Из функции greet_user() стоит вынести еще один блок кода. Если имя пользователя не существует, то код запроса нового имени должен размещаться в функции,\r\n# специализирующейся на решении этой задачи:\r\n# import json\r\n# def get_stored_username():\r\n# \"\"\"Получает хранимое имя пользователя, если оно существует.\"\"\"\r\n# ...\r\n# def get_new_username():\r\n# \"\"\"Запрашивает новое имя пользователя.\"\"\"\r\n# username = input(\"What is your name? \")\r\n# filename = 'username.json'\r\n# with open(filename, 'w') as f_obj:\r\n# json.dump(username, f_obj)\r\n# return usernameИтоги 209\r\n# def greet_user():\r\n# \"\"\"Приветствует пользователя по имени.\"\"\"\r\n# username = get_stored_username()\r\n# if username:\r\n# print(\"Welcome back, \" + username + \"!\")\r\n# else:\r\n# username = get_new_username()\r\n# print(\"We'll remember you when you come back, \" + username + \"!\")\r\n# greet_user()\r\n# Каждая функция в окончательной версии remember_me py имеет четкое, конкретное\r\n# предназначение. Мы вызываем greet_user(), и эта функция выводит нужное приветствие: либо для уже знакомого, либо для\r\n# нового пользователя. Для этого функция вызывает функцию get_stored_username(), которая отвечает только за чтение\r\n# хранимого имени пользователя (если оно есть). Наконец, функция greet_user()\r\n# при необходимости вызывает функцию get_new_username(), которая отвечает только за получение нового имени пользователя\r\n# и его сохранение. Такое «разделение\r\n# обязанностей» является важнейшим аспектом написания чистого кода, простого\r\n# в сопровождении и расширении\r\n\r\n# ---------------------------------------------------------------------------------------------------------------------\r\n\r\n# УПРАЖНЕНИЯ\r\n# 10-11 Любимое число: напишите программу, которая запрашивает у пользователя его любимое число Воспользуйтесь функцией\r\n# json dump() для сохранения этого числа в файле\r\n# Напишите другую программу, которая читает это значение и выводит сообщение: «Я знаю\r\n# ваше любимое число! Это _____»\r\n\r\nimport json\r\n\r\nfilename = 'username.json'\r\ntry:\r\n    with open(filename) as f_obj:\r\n        username = json.load(f_obj)\r\nexcept FileNotFoundError:\r\n    username = input(\"Какое ваше любимое число? \")\r\n    with open(filename, 'w') as f_obj:\r\n        json.dump(username, f_obj)\r\n        print(\"Я запомнил ваше любимое число до следующего раза\")\r\nelse:\r\n    print(\"Ваше любимое число, \" + username + \"!\")\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/faili_i_iskluchenia_chapter10.py b/faili_i_iskluchenia_chapter10.py
--- a/faili_i_iskluchenia_chapter10.py	(revision 8304170c6d00c6f8ac2ed7a6c0abd7d64923fc7a)
+++ b/faili_i_iskluchenia_chapter10.py	(date 1618137006268)
@@ -1297,4 +1297,4 @@
         json.dump(username, f_obj)
         print("Я запомнил ваше любимое число до следующего раза")
 else:
-    print("Ваше любимое число, " + username + "!")
+    print("Ваше любимое число : " + username + "!")
