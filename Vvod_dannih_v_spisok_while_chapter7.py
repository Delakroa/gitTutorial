# Как работает функция input()

# Функция input() приостанавливает выполнение программы и ожидает, пока
# пользователь введет некоторый текст. Получив ввод, Python сохраняет его в пере-
# менной, чтобы вам было удобнее работать с ним.
# Например, следующая программа предлагает пользователю ввести текст, а затем
# выводит сообщение для пользователя:

# messege = input("Скажи мне что нибудь и я это повторю вам: ")
# print(messege)

# --------------------------------------------------------------------------------------------------------------------

# Содержательные подсказки

# Каждый раз, когда в вашей программе используется функция input(), вы должны
# включать четкую, понятную подсказку, которая точно сообщит пользователю,
# какую информацию вы от него хотите получить. Подойдет любое предложение,
# которое сообщает пользователю, что нужно вводить. Пример:

# name = input("Пожадуйста введите ваше имя: ")
# print("Привет, " + name.title() + "!")


# promt = "Если вы сообщите нам, кто вы, мы сможем персонализировать сообщения, которое вы видите."
# promt += "\nКак тебя зовут? "  # оператор += обьединяет текст хранящийся в переменной prompt
#
# name = input(promt)
# print("\nПривет, " + name + "!")

# -----------------------------------------------------------------------------------------------------------------

# Использование int() для получения числового ввода:

# height = input("Какой у вас рост в дюймах? ")
# height = int(height)
# if height >= 36:
#     print("\nВы достаточно высоки, чтобы ездить верхом!")
# else:
#     print("\nВы сможете ездить верхом, когда станете немного старше. ")

# Если пользователь вводит числовые данные, которые используются в вашей про-
# грамме для вычислений и сравнений, обязательно преобразуйте введенное значение
# в его числовой эквивалент.

# ----------------------------------------------------------------------------------------------------------------------

# При работе с числовыми данными может пригодиться оператор вычисления остат-
# ка (%), который делит одно число на другое и возвращает остаток:

# Оператор % не сообщает частное от целочисленного деления; он возвращает только
# остаток.
# Когда одно число нацело делится на другое, остаток равен 0, и оператор % возвра-
# щает 0. Например, этот факт может использоваться для проверки четности или
# нечетности числа:

# number = input("Введите число, и я скажу его чётное или нечётное: ")
# number = int(number)
#
# if number % 2 == 0:
#     print("\nНомер " + str(number) + " чётное.")
# else:
#     print("\nНомер " + str(number) + " нечётный.")

# ---------------------------------------------------------------------------------------------------------------------

# 7-1. Прокат машин: напишите программу, которая спрашивает у пользователя, какую ма-
# шину он хотел бы взять напрокат. Выведите сообщение с введенными данными (например,
# “Дай мне посмотреть, найду ли я тебе Субару”).

# cars = input("какую машину вы хотели бы взять напрокат? ")
# print("\nДай мне посмотреть, найду ли я тебе " + cars)

# --------------------------------------------------------------------------------------------------------------------

# 7-2. Заказ стола: напишите программу, которая спрашивает у пользователя, на сколько
# мест он хочет забронировать стол в ресторане. Если введенное число больше 8, выведите
# сообщение о том, что пользователю придется подождать. В противном случае сообщите,
# что стол готов.

# book_your_place = input("На какое сколько мест вы хотите забронировать стол в ресторане: ")
# book_your_place = int(book_your_place)
# if book_your_place > 8:
#     print("Извините, но вам придётся подождать ")
# else:
#     print("Столы свободны ")

# -------------------------------------------------------------------------------------------------------------------

# 7-3. Числа, кратные 10: запросите у пользователя число и сообщите, кратно оно 10 или нет.

# numbers = input("Введите число: ")
# numbers = int(numbers)
#
# if numbers % 10 == 0:
#     print("Число кратное")
# else:
#     print("Число не кратное")

# -------------------------------------------------------------------------------------------------------------------

# Циклы while
#
# Цикл for получает коллекцию элементов и выполняет блок кода по одному разу
# для каждого элемента в коллекции. В отличие от него, цикл while продолжает вы-
# полняться, пока остается истинным некоторое условие.

# current_number = 1
# while current_number <= 5:
#     print(current_number)
#     current_number += 1

# В первой строке отсчет начинается с 1, для чего current_number присваивается
# значение 1. Далее запускается цикл while, который продолжает работать, пока
# значение current_number остается меньшим или равным 5. Код в цикле выводит
# значение current_number и увеличивает его на 1 командой current_number += 1.
# (Оператор += является сокращенной формой записи для current_number =
# current_number + 1.)
# Цикл повторяется, пока условие current_number <= 5 остается истинным. Так как
# 1 меньше 5, Python выводит 1, а затем увеличивает значение на 1, отчего current_
# number становится равным 2. Так как 2 меньше 5, Python выводит 2 и снова при-
# бавляет 1 и т. д. Как только значение current_number превысит 5, цикл останавли-
# вается, а программа завершается:

# --------------------------------------------------------------------------------------------------------------------

# Пользователь решает прервать работу программы

# prompt = "\nСкажи мне что-нибудь, и я тебе отвечу: "  # В точке  определяется сообщение, которое объясняет,
# prompt += "\nВведи 'quit' чтоб завершить программу. "  # что у пользователя есть два варианта:
# message = ""  # Затем переменной message  присваивается значение, введенное пользователем
# while message != 'quit':  # Цикл while  выполняется, пока значение message не равно 'quit'.
#     message = input(prompt)  # При выполнении команды message = input(prompt) Python отображает
#     print(message)

# При выполнении команды message = input(prompt) Python отображает
# подсказку и ожидает, пока пользователь введет данные. Эти данные сохраняются
# в message и выводятся командой print; после этого Python снова проверяет усло-
# вие команды while. Пока пользователь не введет слово 'quit', приглашение будет
# 126 Глава 7 • Ввод данных и циклы while
# выводиться снова и снова, а Python будет ожидать новых данных. При вводе слова
# 'quit' Python перестает выполнять цикл while, а программа завершается:

# ----------------------------------------------------------------------------------------------------------------------

# prompt = "\nСкажи мне что-нибудь, и я тебе отвечу: "
# prompt += "\nВведи 'quit' чтоб завершить программу. "
# message = ""
# while message != "quit":
#     message = input(prompt)
#     if message != 'quit':
#         print(message)
#
#
# Теперь программа проводит проверку перед выводом сообщения и выводит со-
# общение только в том случае, если оно не совпадает с признаком завершения:

# -------------------------------------------------------------------------------------------------------------------

# ФЛАГИ

# В предыдущем примере программа выполняла некоторые операции, пока заданное
# условие оставалось истинным. А что если вы пишете более сложную программу,
# выполнение которой может прерываться по нескольким разным условиям?
# Например, компьютерная игра может завершаться по разным причинам: у игро-
# ка кончились все «жизни»; прошло отведенное время; все города, которые он
# должен был защищать, были уничтожены и т. д. Игра должна завершаться
# при выполнении любого из этих условий. Попытки проверять все возможные
# условия в одной команде while быстро усложняются и становятся слишком
# громоздкими.

# Если программа должна выполняться только при истинности нескольких условий,
# определите одну переменную-флаг. Эта переменная сообщает, должна ли програм-
# ма выполняться далее. Программу можно написать так, чтобы она продолжала
# выполнение, если флаг находится в состоянии True, и завершалась, если любое
# из нескольких событий перевело флаг в состояние False. В результате в команде
# while достаточно проверить всего одно условие: находится ли флаг в состоянии
# True. Все остальные проверки (которые должны определить, произошло ли собы-
# тие, переводящее флаг в состояние False) удобно организуются в остальном коде.
# Добавим флаг в программу parrot.py из предыдущего раздела. Этот флаг, который
# мы назовем active (хотя переменная может называться как угодно), управляет тем,
# должно ли продолжаться выполнение программы:

prompt = "\nСкажи мне что-нибудь, и я тебе отвечу: "
prompt += "\nВведи 'quit' чтоб завершить программу. "

active = True   # 1
while active:   # 2
    message = input(prompt)

    if message == 'quit':    # 3
        active = False
    else:                    # 4
        print(message)


# В точке  переменной active присваивается True, чтобы программа начинала
# работу в активном состоянии. Это присваивание упрощает команду while, потому
# что в самой команде while никакие сравнения не выполняются; вся логика реали-
# зуется в других частях программы. Пока переменная active остается равной True,
# цикл выполняется.
# В команде if внутри цикла while значение message проверяется после того, как
# пользователь введет данные. Если пользователь ввел строку 'quit' , флаг active
# переходит в состояние False, а цикл while останавливается. Если пользователь ввел
# любой текст, кроме 'quit' , то введенные им данные выводятся как сообщение.
# Результаты работы этой программы ничем не отличаются от предыдущего приме-
# ра, в котором условная проверка выполняется прямо в команде while. Но теперь
# в программе имеется флаг, указывающий, находится ли она в активном состоянии,
# и вы сможете легко добавить новые проверки (в форме команд elif) для событий,
# с которыми переменная active может перейти в состояние False. Это может быть
# удобно в сложных программах — например, в компьютерных играх с многочислен-
# ными событиями, каждое из которых может привести к завершению программы.
# Когда по любому из этих событий флаг active переходит в состояние False, основ-
# ной игровой цикл прервется, выводится сообщение о завершении игры, и у игрока
# появляется возможность сыграть еще раз.