# Эта глава посвящена функциям — именованным блокам кода, предназначенным
# для решения одной конкретной задачи. Чтобы выполнить задачу, определенную
# в виде функции, вы указываете имя функции, отвечающей за эту задачу. Если зада-
# ча должна многократно выполняться в программе, вам не придется заново вводить
# весь необходимый код; просто вызовите функцию, предназначенную для решения
# задачи, и этот вызов приказывает Python выполнить код, содержащийся внутри
# функции. Как вы вскоре убедитесь, использование функций упрощает чтение, на-
# писание, тестирование кода и исправление ошибок.
# В этой главе также рассматриваются возможности передачи информации функ-
# циям. Вы узнаете, как писать функции, основной задачей которых является вывод
# информации, и другие функции, предназначенные для обработки данных и возвра-
# щения значения (или набора значений.) Наконец, вы научитесь хранить функции
# в отдельных файлах, называемых модулями, для упорядочения файлов основной
# программы.

# ---------------------------------------------------------------------------------------------------------------------

# Определение функции

#  def greet_user():
#      """Выводит простое приветствие."""
#      print("Hello!")
#
#  greet_user()

# В этом примере представлена простейшая структура функции. Строка  при по-
# мощи ключевого слова def сообщает Python, что вы определяете функцию. В опре-
# делении функции указывается имя функции и, если нужно, описание информации,
# необходимой функции для решения ее задачи. Эта информация заключается
# в круглые скобки. В данном примере функции присвоено имя greet_user(), и она
# не нуждается в дополнительной информации для решения своей задачи, поэтому
# круглые скобки пусты. (Впрочем, даже в этом случае они обязательны.) Наконец,
# определение завершается двоеточием.
# Все строки с отступами, следующие за def greet_user():, образуют тело функ-
# ции. Текст в точке  представляет собой комментарий — строку документации
# 136 Глава 8 • Функции
# с описанием функции. Строки документации заключаются в утроенные кавычки;
# Python опознает их по этой последовательности символов во время генерирования
# документации к функциям в ваших программах.
# «Настоящий» код в теле этой функции состоит всего из одной строки
# print("Hello!") — см. . Таким образом, функция greet_user() решает всего
# одну задачу: выполнение команды print("Hello!").
# Когда потребуется использовать эту функцию, вызовите ее. Вызов функции при-
# казывает Python выполнить содержащийся в ней код. Чтобы вызвать функцию,
# укажите ее имя, за которым следует вся необходимая информация, заключенная
# в круглые скобки, как показано в строке . Так как никакая дополнительная ин-
# формация не нужна, вызов функции эквивалентен простому выполнению команды
# greet_user(). Как и ожидалось, функция выводит сообщение Hello!:

# -------------------------------------------------------------------------------------------------------------------

# Передача информации функции

# С небольшими изменениями функция greet_user() сможет не только сказать
# «Привет!» пользователю, но и поприветствовать его по имени. Для этого следует
# включить имя username в круглых скобках в определение функции def greet_
# user(). С добавлением username функция примет любое значение, которое будет
# заключено в скобки при вызове. Теперь функция ожидает, что при каждом вызове
# будет передаваться имя пользователя. При вызове greet_user() укажите имя (на-
# пример, 'jesse') в круглых скобках:

# def greet_user(username):
#     """Выводит простое приветствие."""
#     print("Helloy, " + username.title() + "!")

# greet_user('jesse')

# Команда greet_user('jesse') вызывает функцию greet_user() и передает ей
# информацию, необходимую для выполнения команды print. Функция получает
# переданное имя и выводит приветствие для этого имени:
# Hello, Jesse!
# Точно так же команда greet_user('sarah') вызывает функцию greet_user()
# и передает ей строку 'sarah', что приводит к выводу сообщения Hello, Sarah!
# Функцию greet_user() можно вызвать сколько угодно раз и передать ей любое
# имя на ваше усмотрение — и вы будете получать ожидаемый результат.

# --------------------------------------------------------------------------------------------------------------------

# Аргументы и параметры

# Функция greet_user() определена так, что для работы она должна получить
# значение переменной username. После того как функция будет вызвана и полу-
# чит необходимую информацию (имя пользователя), она выведет правильное
# приветствие.
# Передача аргументов 137
# Переменная username в определении greet_user() — параметр, то есть условные
# данные, необходимые функции для выполнения ее работы. Значение 'jesse'
# в greet_user('jesse') — аргумент, то есть конкретная информация, переданная
# при вызове функции. Вызывая функцию, вы заключаете значение, с которым
# функция должна работать, в круглые скобки. В данном случае аргумент 'jesse'
# был передан функции greet_user(), а его значение было сохранено в переменной
# username.

# -------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 8-1. Сообщение: напишите функцию display_message() для вывода сообщения по теме, рас-
# сматриваемой в этой главе. Вызовите функцию и убедитесь в том, что сообщение выво-
# дится правильно.

# def display_massage(trening):
#     """Тренировка"""
#     print("Helloy World! " + trening.title())

# display_massage('dmitry')


# 8-2. Любимая книга: напишите функцию favorite_book(), которая получает один пара-
# метр title. Функция должна выводить сообщение вида «One of my favorite books is Alice in
# Wonderland». Вызовите функцию и убедитесь в том, что название книги правильно пере-
# дается как аргумент при вызове функции.

# def favorite_book(book):
#     """вывод любимой книги"""
#     print("Одна из любимых книг: " + book.title())

# favorite_book("туманность андромеды (ефремова)")

# ------------------------------------------------------------------------------------------------------------------

# Позиционные аргументы

# def describe_pet(animal_type, pet_name):
#     """Выводит информацию животного"""
#     print("\nУ меня есть " + animal_type + ".")
#     print("Моего " + animal_type + " зовут " + pet_name.title() + ".")

# describe_pet('хомяк', 'гарри')

# --------------------------------------------------------------------------------------------------------------------

# Многократный вызов функций

# def describe_pet(animal_type, pet_name):
#     """Выводит информацию о животном."""
#     print("\nI have a " + animal_type + ".")
#     print("My " + animal_type + "'s name is " + pet_name.title() + ".")
#
#
# describe_pet('hamster', 'harry')
# describe_pet('dog', 'willie')

# --------------------------------------------------------------------------------------------------------------------

# Именованные аргументы

# def describe_pet(animal_type, pet_name):
#     """Выводит информацию о животном."""

# print("\nI have a " + animal_type + ".")
# print("My " + animal_type + "'s name is " + pet_name.title() + ".")


# describe_pet(animal_type='hamster', pet_name='harry')

# Функция describe_pet() не изменилась. Однако на этот раз при вызове функ-
# ции мы явно сообщаем Python, с каким параметром должен быть связан каждый
# аргумент. При обработке вызова функции Python знает, что аргумент 'hamster'
# должен быть сохранен в параметре animal_type, а аргумент 'harry' в параметре
# pet_name.
# Порядок следования именованных аргументов в данном случае не важен, потому
# что Python знает, где должно храниться каждое значение. Следующие два вызова
# функции эквивалентны:

# При использовании именованных аргументов будьте внимательны — имена должны точно совпа-
# дать с именами параметров из определения функции.

# -------------------------------------------------------------------------------------------------------------------

# Значения по умолчанию

# Для каждого параметра вашей функции можно определить значение по умолча-
# нию. Если при вызове функции передается аргумент, соответствующий данному
# параметру, Python использует значение аргумента, а если нет — использует зна-
# чение по умолчанию. Таким образом, если для параметра определено значение
# по умолчанию, вы можете опустить соответствующий аргумент, который обычно
# включается в вызов функции. Значения по умолчанию упрощают вызовы функций
# и проясняют типичные способы использования функций.
# Например, если вы заметили, что большинство вызовов describe_pet() исполь-
# зуется для описания собак, задайте animal_type значение по умолчанию 'dog'.
# Теперь в любом вызове describe_pet() для собаки эту информацию можно
# опустить:
# def describe_pet(pet_name, animal_type='dog'):
# """Выводит информацию о животном."""
# print("\nI have a " + animal_type + ".")
# print("My " + animal_type + "'s name is " + pet_name.title() + ".")
# describe_pet(pet_name='willie')

# Мы изменили определение describe_pet() и включили для параметра animal_type
# значение по умолчанию 'dog'. Если теперь функция будет вызвана без указания
# animal_type, Python знает, что для этого параметра следует использовать значение 'dog':
# I have a dog.
# My dog's name is Willie.

# ---------------------------------------------------------------------------------------------------------------------

# Эквивалентные вызовы функций

# Так как позиционные аргументы, именованные аргументы и значения по умол-
# чанию могут использоваться одновременно, часто существуют несколько эквива-
# лентных способов вызова функций. Возьмем оператор describe_pets() с одним
# значением по умолчанию:

# def describe_pet(pet_name, animal_type='dog'):

# При таком определении аргумент для параметра pet_name должен задаваться в любом случае, но это значение может
# передаваться как в позиционном, так и в име - нованном формате.Если описываемое животное не является собакой, то
# аргумент animal_type тоже должен быть включен в вызов, и этот аргумент тоже может быть задан как в позиционном, так
# и в именованном формате. Все следующие вызовы являются допустимыми для данной функции:

# describe_pet('willie')
# describe_pet(pet_name='willie')
# describe_pet('harry', 'hamster')
# describe_pet(pet_name='harry', animal_type='hamster')
# describe_pet(animal_type='hamster', pet_name='harry')

# Все вызовы функции выдадут такой же результат, как и в предыдущих примерах.

# ПРИМЕЧАНИЕ
# На самом деле не так важно, какой стиль вызова вы используете. Если ваша функция выдает нуж-
# ный результат, выберите тот стиль, который вам кажется более понятным.

# --------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 8-3. Футболка: напишите функцию make_shirt(), которая получает размер футболки и текст,
# который должен быть напечатан на ней. Функция должна выводить сообщение с размером
# и текстом. Вызовите функцию с использованием позиционных аргументов. Вызовите функ-
# цию во второй раз с использованием именованных аргументов.

# def make_shirt(size, text):
#     """описание футболки"""

# print('Размер моей футболки ' + size.title() + " с красивым текстом на ней " + text.title())


# make_shirt('xxl', 'hello world')


# def make_shirt(size, text):
#     """именованный агрумент"""
#     print('Размер моей футболки ' + size.title() + " с красивым текстом на ней " + text.title())


# make_shirt(size='XXL', text='hello world')


# --------------------------------------------------------------------------------------------------------------------

# 8-4. Большие футболки: измените функцию make_shirt(), чтобы футболки по умолчанию
# имели размер L, и на них выводился текст «I love Python.». Создайте футболку с размером
# L и текстом по умолчанию, а также футболку любого размера с другим текстом.

# def make_shirt(size, text):
#     """задание"""
#     print('Размер моей футболки ' + size.title() + ', с прикольным текстом на ней: ' + text.title())


# make_shirt(size='l', text='"i love python"')


# -------------------------------------------------------------------------------------------------------------------

# 8-5. Города: напишите функцию describe_city(), которая получает названия города и стра-
# ны. Функция должна выводить простое сообщение (например, «Reykjavik is in Iceland»). За-
# дайте параметру страны значение по умолчанию. Вызовите свою функцию для трех разных
# городов, по крайней мере один из которых не находится в стране по умолчанию.

# def discribe_city(city, country):
#     """описание города"""
#     print('Город ' + city.title() + ' находится в ' + country.title() + ';')


# discribe_city(city='тверь', country='россии')
# discribe_city(city='берлин', country='германии')
# discribe_city(city='рим', country='италии')

# -------------------------------------------------------------------------------------------------------------------

# Возвращаемое значение

# def get_formatted_name(first_name, last_name):  #1
"""Возвращает аккуратно отформатированныое имя."""


# full_name = first_name + ' ' + last_name   #2
# return full_name.title()  #3


# musician = get_formatted_name('jimi', 'hendrix')  #4
# print(musician)

# Определение get_formatted_name() получает в параметрах имя и фамилию .
# Функция объединяет эти два имени, добавляет между ними пробел и сохраняет
# результат в full_name . Значение full_name преобразуется в формат с начальной
# буквой верхнего регистра, а затем возвращается в точку вызова .
# Вызывая функцию, которая возвращает значение, необходимо предоставить пере-
# менную, в которой должно храниться возвращаемое значение. В данном случае
# возвращаемое значение сохраняется в переменной musician . Результат содержит
# аккуратно отформатированное полное имя, построенное из имени и фамилии:
# Jimi Hendrix
# Может показаться, что все эти хлопоты излишни — с таким же успехом можно
# было использовать команду:
# print("Jimi Hendrix")
# Но если представить, что вы пишете большую программу, в которой многочис-
# ленные имена и фамилии должны храниться по отдельности, такие функции, как
# get_formatted_name(), становятся чрезвычайно полезными. Вы храните имена
# отдельно от фамилий, а затем вызываете функцию везде, где потребуется вывести
# полное имя.

# --------------------------------------------------------------------------------------------------------------------

# Необязательные аргументы

# Иногда бывает удобно сделать аргумент необязательным, чтобы разработчик, ис-
# пользующий функцию, мог передать дополнительную информацию только в том
# случае, если он этого захочет. Чтобы сделать аргумент необязательным, можно
# воспользоваться значением по умолчанию. Допустим, вы захотели расширить
# функцию get_formatted_name(), чтобы она также работала и со вторыми именами.
# Первая попытка могла бы выглядеть так:

# def get_formatted_name(first_name, middle_name, last_name):
#     """Возвращает аккуратно отформатированное поля имя."""
#     full_name = first_name + "" + middle_name + " " + last_name
#     return full_name.title()


# musician = get_formatted_name('john', ' lee', 'hooker')
# print(musician)


# Функция работает при получении имени, второго имени и фамилии. Она получает
# все три части имени, а затем строит из них строку. Функция добавляет пробелы
# там, где это уместно, и преобразует полное имя в формат с капитализацией:

# John Lee Hooker

# Однако вторые имена нужны не всегда, а в такой записи функция не будет работать,
# если при вызове ей передаются только имя и фамилия. Чтобы средний аргумент
# был необязательным, можно присвоить аргументу middle_name пустое значение
# по умолчанию; этот аргумент игнорируется, если пользователь не передал для него
# значение. Чтобы функция get_formatted_name() работала без второго имени, сле-
# дует назначить для параметра middle_name пустую строку значением по умолчанию
# и переместить его в конец списка параметров:

# def get_formatted_name(first_name, last_name, middle_name=''):
#     """Возвращает аккуратно отформатированное полное имя."""
#     if middle_name:
#         full_name = first_name + ' ' + middle_name + ' ' + last_name
#         return full_name.title()
#     else:
#         full_name = first_name + ' ' + last_name
#         return full_name.title()


# musician = get_formatted_name('jimi', 'hendrix')
# print(musician)

# musician = get_formatted_name('john', 'hooker', 'lee')
# print(musician)

# ------------------------------------------------------------------------------------------------------------------

# Возвращение словаря

# Функция может вернуть любое значение, нужное вам, в том числе и более сложную
# структуру данных (например, список или словарь). Так, следующая функция полу-
# чает части имени и возвращает словарь, представляющий человека:

# def build_person(first_name, last_name):
#     """Возвращает словарь с информацией человека"""
#     person = {'first': first_name, 'last': last_name}  # 1
#     return person  # 2


# musician = build_person('jimi', 'hendrix')
# print(musician)  # 3

# Функция build_person() получает имя и фамилию и сохраняет полученные зна-
# чения в словаре в точке . Значение first_name сохраняется с ключом 'first',
# а значение last_name — с ключом 'last'. Весь словарь с описанием человека
# возвращается в точке . Возвращаемое значение выводится в точке  с двумя
# исходными фрагментами текстовой информации, теперь хранящимися в словаре:

# Функция получает простую текстовую информацию и помещает ее в более удоб-
# ную структуру данных, которая позволяет работать с информацией (помимо про-
# стого вывода). Строки 'jimi' и 'hendrix' теперь помечены как имя и фамилия.
# Функцию можно легко расширить так, чтобы она принимала дополнительные
# значения: — второе имя, возраст, профессию или любую другую информацию о че-
# ловеке, которую вы хотите сохранить. Например, следующее изменение позволяет
# также сохранить возраст человека:

# def build_person(first_name, last_name, age=''):
#     """Возвращает словарь с информацией о человеке."""
#     person = {'first': first_name, 'last': last_name}
#     if age:
#         person['age'] = age
#     return person


# musician = build_person('Джими', 'Хендрикс', age=27)
# print(musician)

# В определение функции добавляется новый необязательный параметр age, кото-
# рому назначается пустое значение по умолчанию. Если вызов функции включает
# значение этого параметра, то значение сохраняется в словаре. Функция всегда
# сохраняет имя, но ее также можно модифицировать, чтобы она сохраняла любую
# необходимую информацию о человеке.

# --------------------------------------------------------------------------------------------------------------------

# Использование функции в цикле while

# Функции могут использоваться со всеми структурами Python, уже известными
# вам. Например, используем функцию get_formatted_name() в цикле while, чтобы
# поприветствовать пользователей более официально. Первая версия программы,
# приветствующей пользователей по имени и фамилии, может выглядеть так:

# def get_formated_name(first_name, last_name):
#     """Возвращает аккуратно отформатированныыое полное имя."""
#     full_name = first_name + ' ' + last_name
#     return full_name.title()


# Бесконечный цикл!
# while True:
#     print("\nПожалуйста скажи мне своё имя:")  # 1
#     f_name = input("Имя: ")
#     l_name = input("Фамлия: ")

# foramated_name = get_formated_name(f_name, l_name)
# print("\nПривет, " + foramated_name + "!")


# В этом примере используется простая версия get_formatted_name(), без вторых
# имен. В цикле while  имя и фамилия пользователя запрашиваются по отдель-
# ности.
# Но у этого цикла while есть один недостаток: в нем не определено условие завер-
# шения. Где следует разместить условие завершения при запросе серии данных?
# Пользователю нужно предоставить возможность выйти из цикла как можно рань-
# ше, так что в приглашении должен содержаться способ завершения. Команда break
# позволяет немедленно прервать цикл при запросе любого из компонентов:

# def get_formatted_name(first_name, last_name):
#     """Возвращает аккуратно отформатированное полное имя."""
#     full_name = first_name + " " + last_name
#     return full_name.title()


# while True:
#     print("\nПожалуйста скажи мне своё имя: ")
#     print("(Введите 'q'в любое время что бы выйти) ")
#
#     f_name = input("Имя: ")
#     if f_name == "q":
#         break

# l_name = input("Фамилия: ")
# if l_name == "q":
#     break

# formatted_name = get_formatted_name(f_name, l_name)
# print("\nПривет, " + formatted_name + "!")

# ---------------------------------------------------------------------------------------------------------------------

# УПРАЖНЕНИЯ
# 8-6. Названия городов: напишите функцию city_country(), которая получает название го-
# рода и страну. Функция должна возвращать строку в формате “Santiago, Chile”. Вызовите
# свою функцию по крайней мере для трех пар «город—страна» и выведите возвращенное
# значение.

# def city_country(city, country, ):
#     """Вывод возвращённого значения"""
#     description = city + " " + country
#     return description.title()


# full_description = city_country('santiago', 'chile')
# print(full_description)

# full_description = city_country('moscow', 'russia', )
# print(full_description)

# full_description = city_country('wroclav', 'poland')
# print(full_description)

# -------------------------------------------------------------------------------------------------------------------

# 8-7. Альбом: напишите функцию make_album(), которая строит словарь с описанием му-
# зыкального альбома. Функция должна получать имя исполнителя и название альбома
# и возвращать словарь, содержащий эти два вида информации. Используйте функцию
# для создания трех словарей, представляющих разные альбомы. Выведите все возвраща-
# емые значения, чтобы показать, что информация правильно сохраняется во всех трех
# словарях.
# Добавьте в make_album() дополнительный параметр для сохранения количества дорожек
# в альбоме. Если в строку вызова включено значение количества дорожек, добавьте это зна-
# чение в словарь альбома. Создайте как минимум один новый вызов функции с передачей
# количества дорожек в альбоме.

# def make_album(artist, album_title, number_of_lines=""):
#     """Возвращение словаря"""
#     if number_of_lines:
#         description_of_the_artis = {'Имя': artist, 'Название альбома': album_title, 'Кол-во дорожек': number_of_lines}
#         return description_of_the_artis
#     else:
#         description_of_the_artis = {'Имя': artist, 'Название альбома': album_title,}
#         return description_of_the_artis


# full_info = make_album('кипелов', 'колизей')
# print(full_info)
# full_info = make_album('зизитоп', 'ад')
# print(full_info)
# full_info = make_album('филип', 'фиолетовый', 16)
# print(full_info)

# --------------------------------------------------------------------------------------------------------------------

# 8-8. Пользовательские альбомы: начните с программы из упражнения 8-7. Напишите цикл
# while, в котором пользователь вводит исполнителя и название альбома. Затем в цикле вы-
# зывается функция make_album() для введенных пользователей и выводится созданный
# словарь. Не забудьте предусмотреть признак завершения в цикле while.


# def make_album(artist, album_title):
#     """Цикл while"""
#     description_of_the_artis = {"Имя исполнителя": artist, "Название альбома": album_title}
#     return description_of_the_artis


# while True:
#     print("\nПожалуйста введите имя исполнителя и название альбома:")
#     print("(Для выхода в любое время нажмите 'q')\n")

#     name = input("Введите имя испольнителя: ")
#     if name == 'q':
#         break

    # name_album = input("Введите название альбома: ")
    # if name_album == 'q':
    #     break
    # formatted_name = make_album(name.title(), name_album.title())
    # print(formatted_name)


# -------------------------------------------------------------------------------------------------------------------

# Передача списка

# Часто при вызове функции удобно передать список — имен, чисел или более
# сложных объектов (например, словарей). При передаче списка функция получает
# прямой доступ ко всему его содержимому. Мы воспользуемся функциями для того,
# чтобы сделать работу со списком более эффективной.
# Допустим, вы хотите вывести приветствие для каждого пользователя из списка.
# В следующем примере список имен передается функции greet_users(), которая
# выводит приветствие для каждого пользователя по отдельности:

# def greet_users(names):
#     """Вывод простого приветствия для каждого пользователя в списке."""
#     for name in names:
#         msg = "Hello, " + name.title() + "!"
#         print(msg)


# usernames = ['hannah', 'ty', 'margot'] # 1
# greet_users(usernames)

# В соответствии со своим определением функция greet_users() рассчитывает полу-
# чить список имен, который сохраняется в параметре names. Функция перебирает
# полученный список и выводит приветствие для каждого пользователя. В точке 
# мы определяем список пользователей usernames, который затем передается greet_
# users() в вызове функции:

# Результат выглядит именно так, как ожидалось. Каждый пользователь получает
# персональное сообщение, и эту функцию можно вызвать для каждого нового на-
# бора пользователей.

# --------------------------------------------------------------------------------------------------------------------

# Изменение списка в функции

# Если вы передаете список функции, код функции сможет изменить список. Все
# изменения, внесенные в список в теле функции, закрепляются, что позволяет эф-
# фективно работать со списком даже при больших объемах данных.
# Допустим, компания печатает на 3D-принтере модели, предоставленные пользо-
# вателем. Проекты хранятся в списке, а после печати перемещаются в отдельный
# список. В следующем примере приведена реализация, не использующая функции:

# Список моделей, которые необходимо печатать.
# unprinted_designs = ['чехол для айфона', 'робот', 'додекаэдр']
# completed_models = []

# Цикл последовательно печатает каждую модель до конца списка.
# После печати каждая модель перемещается в список completed_models.
# while unprinted_designs:
#     current_design = unprinted_designs.pop()
    # печатает модель на 3D принтере
    # print("Печатает модель: " + current_design.title())
    # completed_models.append(current_design)

# Вывод всех готовых моделей.
# print("\nБыли напечатаны следующие модели:")
# for completed_model in completed_models:
#     print(completed_model.title())


# Мы можем изменить структуру этого кода: для этого следует написать две функ-
# ции, каждая из которых решает одну конкретную задачу. Бульшая часть кода
# останется неизменной; просто программа становится более эффективной. Первая
# функция занимается печатью, а вторая выводит сводку напечатанных моделей:

def pechat_modeli(napechatannii_dizain, gotovie_modeli):    # 1
    """Имитирует печать модели. пока список не станет пустым.
    Каждая модель после печати перемещается в gotovie_modeli."""
    while napechatannii_dizain:
        tekushii_dizain = napechatannii_dizain.pop()

        # Имитация печати модели на 3D-принтере.
        print("Печатает модель: " + tekushii_dizain.title())
        gotovie_modeli.append(tekushii_dizain)

def pokazat_gotovie_modeli(gotovie_modeli):   # 2
    """Выводит информацию обо всех напечатанных моделях."""
    print("\nБыли напечатаны следующие модели: ")
    for gotovie_model in gotovie_modeli:
        print(gotovie_model.title())


napechatannii_dizain = ['чехол для айфона', 'робот', 'додекаэдр']
gotovie_modeli = []
pechat_modeli(napechatannii_dizain, gotovie_modeli)
pokazat_gotovie_modeli(gotovie_modeli)


# В точке  определяется функция pechat_modeli() с двумя параметрами: список
# моделей для печати и список готовых моделей. Функция имитирует печать каж-
# дой модели, последовательно извлекая модели из первого списка и перемещая
# их во второй список. В точке 2 определяется функция porfzat_gotovie_modeli()
# с одним параметром: списком напечатанных моделей. Функция porfzat_gotovie_modeli()
# получает этот список и выводит имена всех напечатанных моделей.
# Программа выводит тот же результат, что и версия без функций, но структура
# кода значительно улучшилась. Код, выполняющий бульшую часть работы, разне-
# сен по двум разным функциям; это упрощает чтение основной части программы.
# Теперь любому разработчику будет намного проще просмотреть код программы
# и понять, что делает программа:
# Программа создает список моделей для печати и пустой список для готовых моде-
# лей. Затем, поскольку обе функции уже определены, остается вызвать их и передать
# правильные аргументы. Мы вызываем pechat_modeli() и передаем два необходимых
# списка; как и ожидалось, pechat_modeli() имитирует печать моделей. Затем вызыва-
# ется функция pokazat_gotovie_modeli(), и ей передается список готовых моделей,
# чтобы функция могла вывести информацию о напечатанных моделях. Благодаря
# содержательным именам функций другой разработчик сможет прочитать этот код
# и понять его даже без комментариев.
# Вдобавок эта программа создает меньше проблем с расширением и сопровождени-
# ем, чем версия без функций. Если позднее потребуется напечатать новую партию
# моделей, достаточно снова вызвать pechat_modeli(). Если окажется, что код печати
# необходимо модифицировать, изменения достаточно внести в одном месте, и они
# автоматически распространятся на все вызовы функции. Такой подход намного
# эффективнее независимой правки кода в нескольких местах программы.
# Этот пример также демонстрирует принцип, в соответствии с которым каждая
# функция должна решать одну конкретную задачу. Первая функция печатает
# каждую модель, а вторая выводит информацию о готовых моделях. Такой подход
# предпочтительнее решения обеих задач в функции. Если вы пишете функцию
# и видите, что она решает слишком много разных задач, попробуйте разделить ее
# код на две функции.
# Помните, что функции всегда можно вызывать из других функций. Эта возмож-
# ность может пригодиться для разбиения сложных задач на серию составляющих.



